Checking _test_.cc...
Checking _test_.cc: __cplusplus...
[simlib.h:671]: (style) C-style pointer casting
[simlib.h:672]: (style) C-style pointer casting
Checking _test_.cc: new_version...
1/52 files checked 0% done
Checking algloop.cc...
Checking algloop.cc: LOOP_DEBUG...
Checking algloop.cc: NDEBUG...
Checking algloop.cc: SIMLIB_DEBUG...
Checking algloop.cc: __cplusplus...
[algloop.cc:180]: (style) The scope of the variable 'count' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:184]: (style) The scope of the variable 'ft' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:284]: (style) The scope of the variable 'count' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:286]: (style) The scope of the variable 'feps' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:287]: (style) The scope of the variable 'prev_root' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:290]: (style) The scope of the variable 'ft' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:401]: (style) The scope of the variable 'count' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:403]: (style) The scope of the variable 'feps' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:406]: (style) The scope of the variable 'aux_root' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:407]: (style) The scope of the variable 'aux_ft' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[algloop.cc:182]: (style) Variable 'fa' is assigned a value that is never used
Checking algloop.cc: new_version...
2/52 files checked 3% done
Checking atexit.cc...
Checking atexit.cc: NDEBUG...
Checking atexit.cc: SIMLIB_DEBUG...
Checking atexit.cc: __cplusplus...
Checking atexit.cc: new_version...
3/52 files checked 4% done
Checking barrier.cc...
Checking barrier.cc: NDEBUG...
Checking barrier.cc: SIMLIB_DEBUG...
Checking barrier.cc: __cplusplus...
Checking barrier.cc: new_version...
4/52 files checked 5% done
Checking calendar.cc...
Checking calendar.cc: MEASURE...
Checking calendar.cc: NDEBUG...
Checking calendar.cc: SIMLIB_DEBUG...
Checking calendar.cc: __cplusplus...
Checking calendar.cc: new_version...
5/52 files checked 16% done
Checking cond.cc...
Checking cond.cc: NDEBUG...
Checking cond.cc: SIMLIB_DEBUG...
Checking cond.cc: __cplusplus...
Checking cond.cc: new_version...
6/52 files checked 17% done
Checking continuous.cc...
Checking continuous.cc: NDEBUG...
Checking continuous.cc: SIMLIB_DEBUG...
Checking continuous.cc: __cplusplus...
Checking continuous.cc: new_version...
7/52 files checked 19% done
Checking debug.cc...
Checking debug.cc: NDEBUG...
Checking debug.cc: SIMLIB_DEBUG...
Checking debug.cc: __cplusplus...
Checking debug.cc: new_version...
8/52 files checked 20% done
Checking delay.cc...
Checking delay.cc: NDEBUG...
Checking delay.cc: NO_DELAY_OPTIMIZATION...
Checking delay.cc: SIMLIB_DEBUG...
Checking delay.cc: SIMLIB_public_Delay_Buffer...
Checking delay.cc: __cplusplus...
[delay.cc:64]: (performance) Checking for 'listptr' emptiness might be inefficient. Using listptr.empty() instead of listptr.size() can be faster. listptr.size() can take linear time but listptr.empty() is guaranteed to take constant time.
[delay.cc:84]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[delay.cc:91]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
Checking delay.cc: new_version...
9/52 files checked 22% done
Checking entity.cc...
Checking entity.cc: NDEBUG...
Checking entity.cc: SIMLIB_DEBUG...
Checking entity.cc: __cplusplus...
Checking entity.cc: new_version...
10/52 files checked 23% done
Checking error.cc...
Checking error.cc: NDEBUG...
Checking error.cc: SIMLIB_DEBUG...
Checking error.cc: __cplusplus...
Checking error.cc: new_version...
11/52 files checked 24% done
Checking errors.cc...
Checking errors.cc: SIMLIB_DEBUG...
Checking errors.cc: __cplusplus...
Checking errors.cc: new_version...
12/52 files checked 25% done
Checking event.cc...
Checking event.cc: NDEBUG...
Checking event.cc: SIMLIB_DEBUG...
Checking event.cc: __cplusplus...
Checking event.cc: new_version...
13/52 files checked 26% done
Checking facility.cc...
Checking facility.cc: NDEBUG...
Checking facility.cc: SIMLIB_DEBUG...
Checking facility.cc: __cplusplus...
Checking facility.cc: new_version...
14/52 files checked 28% done
Checking fun.cc...
Checking fun.cc: NDEBUG...
Checking fun.cc: SIMLIB_DEBUG...
Checking fun.cc: __cplusplus...
Checking fun.cc: new_version...
15/52 files checked 29% done
Checking graph.cc...
Checking graph.cc: NDEBUG...
Checking graph.cc: SIMLIB_DEBUG...
Checking graph.cc: __cplusplus...
Checking graph.cc: hdsfjfhsaj...
Checking graph.cc: new_version...
16/52 files checked 30% done
Checking histo.cc...
Checking histo.cc: NDEBUG...
Checking histo.cc: SIMLIB_DEBUG...
Checking histo.cc: __cplusplus...
Checking histo.cc: new_version...
17/52 files checked 31% done
Checking intg.cc...
Checking intg.cc: NDEBUG...
Checking intg.cc: SIMLIB_DEBUG...
Checking intg.cc: __cplusplus...
[intg.cc:319]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:334]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:349]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:366]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:528]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:543]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:558]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:574]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[intg.cc:590]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
Checking intg.cc: new_version...
18/52 files checked 36% done
Checking link.cc...
Checking link.cc: NDEBUG...
Checking link.cc: SIMLIB_DEBUG...
Checking link.cc: __cplusplus...
Checking link.cc: new_version...
19/52 files checked 37% done
Checking list.cc...
Checking list.cc: NDEBUG...
Checking list.cc: SIMLIB_DEBUG...
Checking list.cc: __cplusplus...
Checking list.cc: new_version...
20/52 files checked 38% done
Checking name.cc...
Checking name.cc: NDEBUG...
Checking name.cc: SIMLIB_DEBUG...
Checking name.cc: __cplusplus...
Checking name.cc: new_version...
21/52 files checked 38% done
Checking ni_abm4.cc...
Checking ni_abm4.cc: NDEBUG...
Checking ni_abm4.cc: SIMLIB_DEBUG...
Checking ni_abm4.cc: __cplusplus...
Checking ni_abm4.cc: new_version...
22/52 files checked 41% done
Checking ni_euler.cc...
Checking ni_euler.cc: NDEBUG...
Checking ni_euler.cc: SIMLIB_DEBUG...
Checking ni_euler.cc: __cplusplus...
Checking ni_euler.cc: new_version...
23/52 files checked 42% done
Checking ni_fw.cc...
Checking ni_fw.cc: NDEBUG...
Checking ni_fw.cc: SIMLIB_DEBUG...
Checking ni_fw.cc: __cplusplus...
Checking ni_fw.cc: new_version...
24/52 files checked 45% done
Checking ni_rke.cc...
Checking ni_rke.cc: NDEBUG...
Checking ni_rke.cc: SIMLIB_DEBUG...
Checking ni_rke.cc: __cplusplus...
Checking ni_rke.cc: new_version...
25/52 files checked 48% done
Checking ni_rkf3.cc...
Checking ni_rkf3.cc: NDEBUG...
Checking ni_rkf3.cc: SIMLIB_DEBUG...
Checking ni_rkf3.cc: __cplusplus...
Checking ni_rkf3.cc: new_version...
26/52 files checked 50% done
Checking ni_rkf5.cc...
Checking ni_rkf5.cc: NDEBUG...
Checking ni_rkf5.cc: SIMLIB_DEBUG...
Checking ni_rkf5.cc: __cplusplus...
Checking ni_rkf5.cc: new_version...
27/52 files checked 52% done
Checking ni_rkf8.cc...
Checking ni_rkf8.cc: NDEBUG...
Checking ni_rkf8.cc: SIMLIB_DEBUG...
Checking ni_rkf8.cc: __cplusplus...
Checking ni_rkf8.cc: new_version...
28/52 files checked 56% done
Checking numint.cc...
Checking numint.cc: NDEBUG...
Checking numint.cc: SIMLIB_DEBUG...
Checking numint.cc: __BCPLUSPLUS__...
Checking numint.cc: __BORLANDC__...
Checking numint.cc: __cplusplus...
[numint.cc:461]: (style) C-style pointer casting
[numint.cc:506]: (style) C-style pointer casting
[numint.cc:539]: (style) C-style pointer casting
[numint.cc:267]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:297]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:606]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:624]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:631]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:651]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:658]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:680]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[numint.cc:687]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
Checking numint.cc: new_version...
29/52 files checked 63% done
Checking object.cc...
Checking object.cc: NDEBUG...
Checking object.cc: SIMLIB_DEBUG...
Checking object.cc: __cplusplus...
Checking object.cc: new_version...
30/52 files checked 63% done
Checking opt-hooke.cc...
Checking opt-hooke.cc: NDEBUG...
Checking opt-hooke.cc: SIMLIB_DEBUG...
Checking opt-hooke.cc: __cplusplus...
Checking opt-hooke.cc: new_version...
31/52 files checked 64% done
Checking opt-param.cc...
Checking opt-param.cc: NDEBUG...
Checking opt-param.cc: SIMLIB_DEBUG...
Checking opt-param.cc: __cplusplus...
[opt-param.cc:73]: (error) Mismatching allocation and deallocation: ParameterVector::p
[opt-param.cc:74]: (error) Mismatching allocation and deallocation: ParameterVector::p
Checking opt-param.cc: new_version...
32/52 files checked 65% done
Checking opt-simann.cc...
Checking opt-simann.cc: NDEBUG...
Checking opt-simann.cc: SIMLIB_DEBUG...
Checking opt-simann.cc: __cplusplus...
Checking opt-simann.cc: new_version...
33/52 files checked 66% done
Checking output1.cc...
Checking output1.cc: NDEBUG...
Checking output1.cc: SIMLIB_DEBUG...
Checking output1.cc: XXX_PRINT_LIST_...
Checking output1.cc: __cplusplus...
Checking output1.cc: new_version...
34/52 files checked 66% done
Checking output2.cc...
Checking output2.cc: NDEBUG...
Checking output2.cc: SIMLIB_DEBUG...
Checking output2.cc: XXX_PRINT_QUEUE_...
Checking output2.cc: __cplusplus...
Checking output2.cc: new_version...
35/52 files checked 69% done
Checking print.cc...
Checking print.cc: NDEBUG...
Checking print.cc: SIMLIB_DEBUG...
Checking print.cc: __cplusplus...
Checking print.cc: new_version...
36/52 files checked 69% done
Checking process.cc...
Checking process.cc: NDEBUG...
Checking process.cc: SIMLIB_DEBUG...
Checking process.cc: __cplusplus...
Checking process.cc: __i386__...
Checking process.cc: __x86_64__...
Checking process.cc: new_version...
37/52 files checked 75% done
Checking queue.cc...
Checking queue.cc: NDEBUG...
Checking queue.cc: SIMLIB_DEBUG...
Checking queue.cc: __cplusplus...
[queue.cc:136]: (style) C-style pointer casting
Checking queue.cc: new_version...
38/52 files checked 76% done
Checking random1.cc...
Checking random1.cc: NDEBUG...
Checking random1.cc: SIMLIB_DEBUG...
Checking random1.cc: __cplusplus...
Checking random1.cc: new_version...
39/52 files checked 77% done
Checking random2.cc...
Checking random2.cc: NDEBUG...
Checking random2.cc: SIMLIB_DEBUG...
Checking random2.cc: __cplusplus...
[random2.cc:37]: (style) The scope of the variable 'i' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[random2.cc:38]: (style) The scope of the variable 'PROD' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[random2.cc:231]: (style) The scope of the variable 'Y' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
[random2.cc:231]: (style) The scope of the variable 'X' can be reduced. Warning: It can be unsafe to fix this message. Be careful. Especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.
Checking random2.cc: new_version...
40/52 files checked 78% done
Checking run.cc...
Checking run.cc: NDEBUG...
Checking run.cc: SIMLIB_DEBUG...
Checking run.cc: __cplusplus...
Checking run.cc: new_version...
41/52 files checked 82% done
Checking sampler.cc...
Checking sampler.cc: NDEBUG...
Checking sampler.cc: SIMLIB_DEBUG...
Checking sampler.cc: __cplusplus...
Checking sampler.cc: new_version...
42/52 files checked 83% done
Checking semaphor.cc...
Checking semaphor.cc: NDEBUG...
Checking semaphor.cc: SIMLIB_DEBUG...
Checking semaphor.cc: __cplusplus...
Checking semaphor.cc: new_version...
43/52 files checked 83% done
Checking simlib2D.cc...
Checking simlib2D.cc: NDEBUG...
Checking simlib2D.cc: SIMLIB_DEBUG...
Checking simlib2D.cc: __cplusplus...
Checking simlib2D.cc: new_version...
44/52 files checked 86% done
Checking simlib3D.cc...
Checking simlib3D.cc: NDEBUG...
Checking simlib3D.cc: SIMLIB_DEBUG...
Checking simlib3D.cc: __cplusplus...
Checking simlib3D.cc: new_version...
45/52 files checked 90% done
Checking stat.cc...
Checking stat.cc: NDEBUG...
Checking stat.cc: SIMLIB_DEBUG...
Checking stat.cc: __cplusplus...
Checking stat.cc: new_version...
46/52 files checked 90% done
Checking stdblock.cc...
Checking stdblock.cc: NDEBUG...
Checking stdblock.cc: SIMLIB_DEBUG...
Checking stdblock.cc: __cplusplus...
Checking stdblock.cc: new_version...
47/52 files checked 93% done
Checking store.cc...
Checking store.cc: NDEBUG...
Checking store.cc: SIMLIB_DEBUG...
Checking store.cc: __cplusplus...
Checking store.cc: new_version...
48/52 files checked 94% done
Checking tstat.cc...
Checking tstat.cc: NDEBUG...
Checking tstat.cc: SIMLIB_DEBUG...
Checking tstat.cc: __cplusplus...
Checking tstat.cc: new_version...
49/52 files checked 95% done
Checking version.cc...
Checking version.cc: NDEBUG...
Checking version.cc: SIMLIB_DEBUG...
Checking version.cc: __cplusplus...
Checking version.cc: new_version...
50/52 files checked 95% done
Checking waitunti.cc...
Checking waitunti.cc: NDEBUG...
Checking waitunti.cc: SIMLIB_DEBUG...
Checking waitunti.cc: __cplusplus...
[waitunti.cc:157]: (style) C-style pointer casting
Checking waitunti.cc: new_version...
51/52 files checked 97% done
Checking zdelay.cc...
Checking zdelay.cc: NDEBUG...
Checking zdelay.cc: SIMLIB_DEBUG...
Checking zdelay.cc: __cplusplus...
[zdelay.cc:54]: (performance) Checking for 'container' emptiness might be inefficient. Using container.empty() instead of container.size() can be faster. container.size() can take linear time but container.empty() is guaranteed to take constant time.
[zdelay.cc:73]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[zdelay.cc:126]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[zdelay.cc:139]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[zdelay.cc:166]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
[zdelay.cc:168]: (performance) Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
Checking zdelay.cc: new_version...
52/52 files checked 100% done
Checking usage of global functions..
[delay.cc:81]: (style) The function 'SampleAll' is never used
