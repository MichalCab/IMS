!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER
A1	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A1	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3
A1	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A1	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A10	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
A11	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
A12	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
A13	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
A2	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A2	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3
A2	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A2	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A3	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A3	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3
A3	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A3	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A4	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A4	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A4	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A5	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A5	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A5	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A6	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A6	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5
A6	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A7	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE
A7	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8
A8	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
A9	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8
ABM4	ni_abm4.h	/^  ABM4(const char* name, const char* slave_name):$/;"	f	class:simlib3::ABM4
ABM4	ni_abm4.h	/^class ABM4 : public MultiStepMethod {$/;"	c	namespace:simlib3
ABM_Count	ni_abm4.h	/^  int ABM_Count;  \/\/ # of start steps (done by starting method)$/;"	m	class:simlib3::ABM4
ACos	fun.cc	/^Input ACos(Input x)             { return new Function1(x, acos); }$/;"	f	namespace:simlib3
ALLOC_CONTEXT	process.cc	169;"	d	file:
AL_BadBounds	errors.h	/^\/* 71 *\/ AL_BadBounds,$/;"	e	enum:_ErrEnum
AL_BadInitVal	errors.h	/^\/* 72 *\/ AL_BadInitVal,$/;"	e	enum:_ErrEnum
AL_Diverg	errors.h	/^\/* 73 *\/ AL_Diverg,$/;"	e	enum:_ErrEnum
AL_MaxCount	errors.h	/^\/* 74 *\/ AL_MaxCount,$/;"	e	enum:_ErrEnum
AL_NotInLoop	errors.h	/^\/* 75 *\/ AL_NotInLoop,$/;"	e	enum:_ErrEnum
ASin	fun.cc	/^Input ASin(Input x)             { return new Function1(x, asin); }$/;"	f	namespace:simlib3
ATan	fun.cc	/^Input ATan(Input x)             { return new Function1(x, atan); }$/;"	f	namespace:simlib3
ATan2	fun.cc	/^Input ATan2(Input y, Input x)   { return new Function2(y, x, atan2); }$/;"	f	namespace:simlib3
Abort	run.cc	/^void Abort()$/;"	f	namespace:simlib3
Abs	fun.cc	/^Input Abs(Input x)              { return new Function1(x, fabs); }$/;"	f	namespace:simlib3
Abs	simlib2D.cc	/^Input Abs(Input2D x) { return new _Abs2D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3
Abs	simlib3D.cc	/^Input Abs(Input3D x) { return new _Abs3D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3
AbsoluteError	intg.cc	/^const double &AbsoluteError=SIMLIB_AbsoluteError; \/\/!< max. abs. error of integration$/;"	m	namespace:simlib3	file:
AccuracyError	errors.h	/^\/* 13 *\/ AccuracyError,$/;"	e	enum:_ErrEnum
Activate	entity.cc	/^void Entity::Activate(double t)$/;"	f	class:simlib3::Entity
Activate	process.cc	/^void Process::Activate(double t)$/;"	f	class:simlib3::Process
Activate	simlib.h	/^    void Activate() { Activate(Time); } \/\/!< activate now$/;"	f	class:simlib3::Entity
Activate	simlib.h	/^inline void Activate(Entity *e)  { e->Activate(); }   \/\/!< activate entity e$/;"	f	namespace:simlib3
ActivateAll	sampler.cc	/^void Sampler::ActivateAll()$/;"	f	class:simlib3::Sampler
ActivationTime	calendar.cc	/^double Entity::ActivationTime() { \/\/ activation time$/;"	f	class:simlib3::Entity
Adaptor2D	simlib2D.h	/^  Adaptor2D(Input _x, Input _y) : x(_x), y(_y) {}$/;"	f	class:simlib3::Adaptor2D
Adaptor2D	simlib2D.h	/^class Adaptor2D : public aContiBlock2D {$/;"	c	namespace:simlib3
Adaptor3D	simlib3D.h	/^  Adaptor3D(Input _x, Input _y, Input _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:simlib3::Adaptor3D
Adaptor3D	simlib3D.h	/^class Adaptor3D : public aContiBlock3D {$/;"	c	namespace:simlib3
AlgLoop	algloop.cc	/^AlgLoop::AlgLoop(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop
AlgLoop	simlib.h	/^class AlgLoop : public aContiBlock1 {$/;"	c	namespace:simlib3
AlgLoopDetected	errors.h	/^\/* 63 *\/ AlgLoopDetected,$/;"	e	enum:_ErrEnum
AlgLoopDetector	internal.h	/^    AlgLoopDetector(aContiBlock *x): block(x)  { lock(); }$/;"	f	class:simlib3::AlgLoopDetector
AlgLoopDetector	internal.h	/^class AlgLoopDetector {$/;"	c	namespace:simlib3
AllActions	cond.cc	/^void aCondition::AllActions()$/;"	f	class:simlib3::aCondition
Alloc	histo.cc	/^static unsigned *Alloc(unsigned n)$/;"	f	namespace:simlib3
Backlash	simlib.h	/^typedef Blash Backlash; \/\/ alias$/;"	t	namespace:simlib3
BadQntzrStep	errors.h	/^\/* 65 *\/ BadQntzrStep,$/;"	e	enum:_ErrEnum
BadUniformParam	errors.h	/^\/* 68 *\/ BadUniformParam,$/;"	e	enum:_ErrEnum
Barrier	barrier.cc	/^Barrier::Barrier(const char *name, unsigned height):$/;"	f	class:simlib3::Barrier
Barrier	barrier.cc	/^Barrier::Barrier(unsigned height):$/;"	f	class:simlib3::Barrier
Barrier	simlib.h	/^class Barrier : public SimObject {$/;"	c	namespace:simlib3
Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::IntegratorContainer
Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::StatusContainer
Behavior	_test_.cc	/^  void Behavior() {$/;"	f	class:TestProcess
Behavior	graph.cc	/^void Graph::Behavior()$/;"	f	class:simlib3::Graph
Behavior	sampler.cc	/^void Sampler::Behavior() {$/;"	f	class:simlib3::Sampler
Behavior	zdelay.cc	/^void ZDelayTimer::Behavior()$/;"	f	class:simlib3::ZDelayTimer
Beta	random2.cc	/^double Beta(double th, double fi, double min, double max)$/;"	f	namespace:simlib3
Bisect	simlib.h	/^  Bisect(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Bisect
Bisect	simlib.h	/^class Bisect : public AlgLoop {$/;"	c	namespace:simlib3
Blash	simlib.h	/^class Blash : public Status {    \/\/ backlash$/;"	c	namespace:simlib3
Blash	stdblock.cc	/^Blash::Blash(Input i, double _p1, double _p2, double _tga)$/;"	f	class:simlib3::Blash
Boolean	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	g	file:
Break	barrier.cc	/^int Barrier::Break() {$/;"	f	class:simlib3::Barrier
BucketList	calendar.cc	/^    typedef CalendarListImplementation BucketList;$/;"	t	class:simlib3::CalendarQueue	file:
Buffer	delay.cc	/^struct Delay::Buffer {          \/\/ INTERFACE: memory for delayed signal$/;"	s	class:simlib3::Delay	file:
Buffer	delay.h	/^    struct Buffer {             \/\/ INTERFACE: memory for delayed signal$/;"	s	class:simlib3::Delay
Busy	simlib.h	/^  bool Busy() const { return in!=0; }$/;"	f	class:simlib3::Facility
CALL_HOOK	internal.h	259;"	d
CANARY1	process.cc	355;"	d	file:
CANARY2	process.cc	511;"	d	file:
CHECK	link.cc	29;"	d	file:
CHECKENTITY	entity.cc	27;"	d	file:
CHECKENTITY	facility.cc	34;"	d	file:
CHECKFACILITY	facility.cc	33;"	d	file:
CHECKQUEUE	entity.cc	28;"	d	file:
CHECKQUEUE	facility.cc	32;"	d	file:
CHECKQUEUE	store.cc	33;"	d	file:
CHECKSTORE	store.cc	34;"	d	file:
CHECKTSTAT	tstat.cc	29;"	d	file:
COEF_PAR	calendar.cc	/^const double COEF_PAR     = 1.5;  \/\/ TODO:tune parameter: cca 1.5$/;"	m	namespace:simlib3	file:
Calendar	calendar.cc	/^    Calendar(): _size(0), mintime(SIMLIB_MAXTIME) {}$/;"	f	class:simlib3::Calendar
Calendar	calendar.cc	/^class Calendar { \/\/ abstract base class$/;"	c	namespace:simlib3	file:
CalendarList	calendar.cc	/^    CalendarList() {$/;"	f	class:simlib3::CalendarList	file:
CalendarList	calendar.cc	/^class CalendarList : public Calendar {$/;"	c	namespace:simlib3	file:
CalendarListImplementation	calendar.cc	/^    CalendarListImplementation() { }$/;"	f	class:simlib3::CalendarListImplementation
CalendarListImplementation	calendar.cc	/^class CalendarListImplementation {$/;"	c	namespace:simlib3	file:
CalendarQueue	calendar.cc	/^CalendarQueue::CalendarQueue():$/;"	f	class:simlib3::CalendarQueue
CalendarQueue	calendar.cc	/^class CalendarQueue : public Calendar {$/;"	c	namespace:simlib3	file:
Cancel	simlib.h	/^    void Cancel() { Terminate(); }      \/\/!< end Behavior() and remove entity$/;"	f	class:simlib3::Entity
CantCloseOutFile	errors.h	/^\/* 62 *\/ CantCloseOutFile,$/;"	e	enum:_ErrEnum
CantCreateIntg	errors.h	/^\/* 37 *\/ CantCreateIntg,$/;"	e	enum:_ErrEnum
CantCreateStatus	errors.h	/^\/* 39 *\/ CantCreateStatus,$/;"	e	enum:_ErrEnum
CantDestroyIntg	errors.h	/^\/* 38 *\/ CantDestroyIntg,$/;"	e	enum:_ErrEnum
CantDestroyStatus	errors.h	/^\/* 40 *\/ CantDestroyStatus,$/;"	e	enum:_ErrEnum
CantOpenOutFile	errors.h	/^\/* 61 *\/ CantOpenOutFile,$/;"	e	enum:_ErrEnum
Capacity	simlib.h	/^  unsigned long Capacity() const { return capacity; }   \/\/!< max capacity$/;"	f	class:simlib3::Store
Change	simlib.h	/^  bool Change() { return ccl!=cc; }     \/\/ both changes$/;"	f	class:simlib3::Condition
ChangeHeight	barrier.cc	/^void Barrier::ChangeHeight(unsigned new_height) {$/;"	f	class:simlib3::Barrier
CheckUniq	generr.c	/^int CheckUniq(TABLE * t)$/;"	f
Clear	barrier.cc	/^void Barrier::Clear() {$/;"	f	class:simlib3::Barrier
Clear	calendar.cc	/^void SQS::Clear() {                       \/\/ remove all$/;"	f	class:simlib3::SQS
Clear	facility.cc	/^void Facility::Clear()$/;"	f	class:simlib3::Facility
Clear	histo.cc	/^void Histogram::Clear()$/;"	f	class:simlib3::Histogram
Clear	semaphor.cc	/^void Semaphore::Clear() {$/;"	f	class:simlib3::Semaphore
Clear	simlib.h	/^    void Clear()  { clear(); }$/;"	f	class:simlib3::Queue
Clear	stat.cc	/^void Stat::Clear()$/;"	f	class:simlib3::Stat
Clear	store.cc	/^void Store::Clear()$/;"	f	class:simlib3::Store
Clear	tstat.cc	/^void TStat::Clear(double initval)$/;"	f	class:simlib3::TStat
ClearAllValueOK	intg.cc	/^void StatusContainer::ClearAllValueOK()$/;"	f	class:simlib3::StatusContainer
Condition	cond.cc	/^Condition::Condition(Input i) :$/;"	f	class:simlib3::Condition
Condition	simlib.h	/^class Condition : public aCondition {  \/\/ state condition$/;"	c	namespace:simlib3
ConditionDown	simlib.h	/^  ConditionDown(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionDown
ConditionDown	simlib.h	/^class ConditionDown : public Condition { \/\/ state event on TRUE-->FALSE change$/;"	c	namespace:simlib3
ConditionUp	simlib.h	/^  ConditionUp(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionUp
ConditionUp	simlib.h	/^class ConditionUp : public Condition { \/\/ state event on FALSE-->TRUE change$/;"	c	namespace:simlib3
Constant	simlib.h	/^  Constant(double x) : value(x) {}$/;"	f	class:simlib3::Constant
Constant	simlib.h	/^class Constant : public aContiBlock {$/;"	c	namespace:simlib3
Constant2D	simlib2D.h	/^  explicit Constant2D(Value2D x) : value(x) {}$/;"	f	class:simlib3::Constant2D
Constant2D	simlib2D.h	/^  explicit Constant2D(double x, double y) : value(x,y) {}$/;"	f	class:simlib3::Constant2D
Constant2D	simlib2D.h	/^class Constant2D : public aContiBlock2D {$/;"	c	namespace:simlib3
Constant3D	simlib3D.h	/^  explicit Constant3D(Value3D x) : value(x) {}$/;"	f	class:simlib3::Constant3D
Constant3D	simlib3D.h	/^  explicit Constant3D(double x, double y, double z) : value(x,y,z) {}$/;"	f	class:simlib3::Constant3D
Constant3D	simlib3D.h	/^class Constant3D : public aContiBlock3D {$/;"	c	namespace:simlib3
ContractStep	intg.cc	/^void ContractStep() {$/;"	f	namespace:simlib3
ContractStep	intg.cc	/^void ContractStep(double time)$/;"	f	namespace:simlib3
Copyright	errors.h	/^\/* 0 *\/ Copyright,$/;"	e	enum:_ErrEnum
Cos	fun.cc	/^Input Cos(Input x)              { return new Function1(x, cos); }$/;"	f	namespace:simlib3
Count	simlib.h	/^  unsigned Count() const { return count; }$/;"	f	class:simlib3::Histogram
Create	calendar.cc	/^inline EventNotice *EventNotice::Create(Entity *e, double t)$/;"	f	class:simlib3::EventNotice
CtrInit	graph.cc	/^void Graph::CtrInit(char *name) \/\/ common initialization$/;"	f	class:simlib3::Graph
CtrInit	intg.cc	/^void Integrator::CtrInit() {$/;"	f	class:simlib3::Integrator
CtrInit	intg.cc	/^void Status::CtrInit() {$/;"	f	class:simlib3::Status
Current	run.cc	/^Entity *const &Current = SIMLIB_Current;        \/\/ read-only reference$/;"	m	namespace:simlib3	file:
CurrentMethodPtr	numint.cc	/^IntegrationMethod* IntegrationMethod::CurrentMethodPtr = &rke;$/;"	m	class:simlib3::IntegrationMethod	file:
CurrentMethodPtr	simlib.h	/^  static IntegrationMethod* CurrentMethodPtr;  \/\/ method used at present$/;"	m	class:simlib3::IntegrationMethod
DBG_ALL	internal.h	95;"	d
DBG_ATEXIT	internal.h	112;"	d
DBG_BEXPR	internal.h	107;"	d
DBG_CALENDAR	internal.h	105;"	d
DBG_CHG	internal.h	99;"	d
DBG_CONTI	internal.h	101;"	d
DBG_CTR	internal.h	97;"	d
DBG_FACSTO	internal.h	102;"	d
DBG_INIT	internal.h	98;"	d
DBG_MODULE	internal.h	111;"	d
DBG_NEW	internal.h	96;"	d
DBG_NUMINT	internal.h	109;"	d
DBG_PROCESS	internal.h	103;"	d
DBG_QUEUE	internal.h	104;"	d
DBG_SIMULATOR	internal.h	106;"	d
DBG_STEP	internal.h	100;"	d
DBG_THREAD	internal.h	110;"	d
DBG_WU	internal.h	108;"	d
DEBUG	internal.h	78;"	d
DEBUG	internal.h	89;"	d
DEBUG_INFO	internal.h	79;"	d
DEBUG_INFO	internal.h	82;"	d
DEFAULT_PRIORITY	simlib.h	/^  DEFAULT_PRIORITY = 0$/;"	e	enum:simlib3::__anon4
DEFINE_HOOK	internal.h	248;"	d
DeadZone	simlib.h	/^typedef Insv DeadZone;$/;"	t	namespace:simlib3
Debug	debug.cc	/^unsigned long Debug(unsigned long mode)$/;"	f	namespace:simlib3
DebugOFF	debug.cc	/^void DebugOFF()$/;"	f	namespace:simlib3
DebugON	debug.cc	/^void DebugON()$/;"	f	namespace:simlib3
Default	zdelay.h	/^    static const bool Default = true;$/;"	m	class:simlib3::ZDelayTimer
Delay	delay.cc	/^Delay::Delay(Input i, double _dt, double ival) :$/;"	f	class:simlib3::Delay
Delay	delay.h	/^class Delay : public aContiBlock1 {$/;"	c	namespace:simlib3
DelayTimeErr	errors.h	/^\/* 86 *\/ DelayTimeErr,$/;"	e	enum:_ErrEnum
DeletingActive	errors.h	/^\/* 18 *\/ DeletingActive,$/;"	e	enum:_ErrEnum
Destroy	calendar.cc	/^inline void EventNotice::Destroy(EventNotice *en)$/;"	f	class:simlib3::EventNotice
Destroy	delay.cc	/^    static void Destroy() {     \/\/ should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_Delay	file:
Destroy	zdelay.cc	/^    static void Destroy() {     \/\/ should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:
Down	simlib.h	/^  bool Down()   { return ccl>cc; }      \/\/ change: TRUE->FALSE$/;"	f	class:simlib3::Condition
Dprintf	internal.h	77;"	d
Dprintf	internal.h	84;"	d
DuplicateCalendar	errors.h	/^\/* 17 *\/ DuplicateCalendar,$/;"	e	enum:_ErrEnum
ERR	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW
ERROREXIT	internal.h	/^    ERROREXIT       \/\/ fatal error handling phase$/;"	e	enum:simlib3::SIMLIB_Phase_t
EULER	ni_euler.h	/^  EULER(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::EULER
EULER	ni_euler.h	/^class EULER : public StatusMethod {$/;"	c	namespace:simlib3
Empty	calendar.cc	/^    bool     Empty() const { return _size == 0; }$/;"	f	class:simlib3::Calendar
Empty	calendar.cc	/^bool SQS::Empty() {                       \/\/ used by Run() only$/;"	f	class:simlib3::SQS
Empty	simlib.h	/^    bool Empty()  { return empty(); }$/;"	f	class:simlib3::Queue
Empty	simlib.h	/^  bool Empty() const  { return Used() == 0; }           \/\/!< store is empty$/;"	f	class:simlib3::Store
EmptyCalendar	errors.h	/^\/* 20 *\/ EmptyCalendar,$/;"	e	enum:_ErrEnum
EmptyWUListError	errors.h	/^\/* 30 *\/ EmptyWUListError,$/;"	e	enum:_ErrEnum
End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::IntegratorContainer
End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::StatusContainer
EndTime	run.cc	/^const double & EndTime   = SIMLIB_EndTime;      \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
EndTime	simlib.h	/^  double EndTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t
Enter	barrier.cc	/^void Barrier::Enter(Entity * e) \/\/TODO without parameter: use Current?$/;"	f	class:simlib3::Barrier
Enter	process.cc	/^void Process::Enter(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process
Enter	store.cc	/^void Store::Enter(Entity *e, unsigned long rcap)$/;"	f	class:simlib3::Store
EnterCapError	errors.h	/^\/* 46 *\/ EnterCapError,$/;"	e	enum:_ErrEnum
Entity	entity.cc	/^Entity::Entity(Priority_t p) :$/;"	f	class:simlib3::Entity
Entity	simlib.h	/^class Entity : public Link {$/;"	c	namespace:simlib3
EntityIsNotScheduled	errors.h	/^\/* 33 *\/ EntityIsNotScheduled,$/;"	e	enum:_ErrEnum
EntityPriority_t	simlib.h	/^typedef signed char EntityPriority_t;$/;"	t	namespace:simlib3
EntityRefError	errors.h	/^\/* 32 *\/ EntityRefError,$/;"	e	enum:_ErrEnum
Eps	simlib.h	/^  double Eps; \/\/ required accuracy$/;"	m	class:simlib3::AlgLoop
Erase	intg.cc	/^void IntegratorContainer::Erase(IntegratorContainer::iterator it)$/;"	f	class:simlib3::IntegratorContainer
Erase	intg.cc	/^void StatusContainer::Erase(StatusContainer::iterator it)$/;"	f	class:simlib3::StatusContainer
Erlang	random2.cc	/^double Erlang(double alfa, int beta)$/;"	f	namespace:simlib3
ErlangError	errors.h	/^\/* 51 *\/ ErlangError,$/;"	e	enum:_ErrEnum
ErrBadArguments	generr.c	/^\/* 1 *\/ ErrBadArguments,$/;"	e	enum:ErrEnum	file:
ErrBadFile	generr.c	/^\/* 2 *\/ ErrBadFile,$/;"	e	enum:ErrEnum	file:
ErrBadHeader	generr.c	/^\/* 3 *\/ ErrBadHeader,$/;"	e	enum:ErrEnum	file:
ErrBadIdentifier	generr.c	/^\/* 4 *\/ ErrBadIdentifier,$/;"	e	enum:ErrEnum	file:
ErrCantOpenIn	generr.c	/^\/* 5 *\/ ErrCantOpenIn,$/;"	e	enum:ErrEnum	file:
ErrCantOpenOut	generr.c	/^\/* 6 *\/ ErrCantOpenOut,$/;"	e	enum:ErrEnum	file:
ErrDuplicateId	generr.c	/^\/* 7 *\/ ErrDuplicateId,$/;"	e	enum:ErrEnum	file:
ErrEnum	generr.c	/^enum ErrEnum {$/;"	g	file:
ErrId	generr.c	/^    char *ErrId;$/;"	m	struct:tabitem	file:
ErrIdTooLong	generr.c	/^\/* 8 *\/ ErrIdTooLong,$/;"	e	enum:ErrEnum	file:
ErrLineTooLong	generr.c	/^\/* 9 *\/ ErrLineTooLong,$/;"	e	enum:ErrEnum	file:
ErrMsg	generr.c	/^    char *ErrMsg;$/;"	m	struct:tabitem	file:
ErrMsg	generr.c	/^char *ErrMsg(enum ErrEnum N)$/;"	f
ErrNoIdentifier	generr.c	/^\/* 10 *\/ ErrNoIdentifier,$/;"	e	enum:ErrEnum	file:
ErrNoMemory	generr.c	/^\/* 11 *\/ ErrNoMemory,$/;"	e	enum:ErrEnum	file:
ErrTooManyMsg	generr.c	/^\/* 12 *\/ ErrTooManyMsg,$/;"	e	enum:ErrEnum	file:
Error	print.cc	/^void Error(const char *fmt, ...)$/;"	f	namespace:simlib3
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Add	file:
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Div	file:
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Mul	file:
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Sub	file:
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_UMinus	file:
Eval	intg.cc	/^void Integrator::Eval()$/;"	f	class:simlib3::Integrator
Eval	intg.cc	/^void Status::Eval()$/;"	f	class:simlib3::Status
Eval	simlib.h	/^    virtual void Eval() {};$/;"	f	class:simlib3::aContiBlock
Eval	simlib2D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock2D
Eval	simlib3D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock3D
Eval	stdblock.cc	/^void Blash::Eval()$/;"	f	class:simlib3::Blash
Eval	stdblock.cc	/^void Hyst::Eval()$/;"	f	class:simlib3::Hyst
Eval	stdblock.cc	/^void Relay::Eval()$/;"	f	class:simlib3::Relay
EvaluateAll	intg.cc	/^void IntegratorContainer::EvaluateAll()$/;"	f	class:simlib3::IntegratorContainer
EvaluateAll	intg.cc	/^void StatusContainer::EvaluateAll()$/;"	f	class:simlib3::StatusContainer
Event	event.cc	/^Event::Event(Priority_t p) : Entity(p)$/;"	f	class:simlib3::Event
Event	simlib.h	/^class Event : public Entity {$/;"	c	namespace:simlib3
EventCount	simlib.h	/^  long   EventCount;    \/\/ for discrete simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t
EventNotice	calendar.cc	/^    EventNotice(Entity *p, double t) :$/;"	f	struct:simlib3::EventNotice
EventNotice	calendar.cc	/^struct EventNotice : public EventNoticeLinkBase {$/;"	s	namespace:simlib3	file:
EventNoticeAllocator	calendar.cc	/^    EventNoticeAllocator(): l(0), freed(0) {}$/;"	f	class:simlib3::EventNoticeAllocator
EventNoticeAllocator	calendar.cc	/^class EventNoticeAllocator {$/;"	c	namespace:simlib3	file:
EventNoticeLinkBase	calendar.cc	/^    EventNoticeLinkBase() : pred(this), succ(this) {}$/;"	f	struct:simlib3::EventNoticeLinkBase
EventNoticeLinkBase	calendar.cc	/^struct EventNoticeLinkBase { \/\/ base class with list pointers only$/;"	s	namespace:simlib3	file:
Exp	fun.cc	/^Input Exp(Input x)              { return new Function1(x, exp); }$/;"	f	namespace:simlib3
Exponential	random2.cc	/^double Exponential(double mv)$/;"	f	namespace:simlib3
Expression	simlib.h	/^  Expression(Input i) : aContiBlock1(i) {}$/;"	f	struct:simlib3::Expression
Expression	simlib.h	/^struct Expression : public aContiBlock1 {$/;"	s	namespace:simlib3
Expression2D	simlib2D.h	/^  explicit Expression2D(Input2D i) : aContiBlock2D1(i) {}$/;"	f	struct:simlib3::Expression2D
Expression2D	simlib2D.h	/^struct Expression2D : public aContiBlock2D1 {$/;"	s	namespace:simlib3
Expression3D	simlib3D.h	/^  explicit Expression3D(Input3D i) : aContiBlock3D1(i) {}$/;"	f	struct:simlib3::Expression3D
Expression3D	simlib3D.h	/^struct Expression3D : public aContiBlock3D1 {$/;"	s	namespace:simlib3
FALSE	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	e	enum:Boolean	file:
FREE_CONTEXT	process.cc	174;"	d	file:
FW	ni_fw.h	/^  FW(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::FW
FW	ni_fw.h	/^class FW : public SingleStepMethod {$/;"	c	namespace:simlib3
FW_First	ni_fw.h	/^  bool FW_First;  \/\/ is method called for first time?$/;"	m	class:simlib3::FW
FacInterruptError	errors.h	/^\/* 42 *\/ FacInterruptError,$/;"	e	enum:_ErrEnum
Facility	facility.cc	/^Facility::Facility()$/;"	f	class:simlib3::Facility
Facility	facility.cc	/^Facility::Facility(Queue * queue)$/;"	f	class:simlib3::Facility
Facility	facility.cc	/^Facility::Facility(const char *name)$/;"	f	class:simlib3::Facility
Facility	facility.cc	/^Facility::Facility(const char *name, Queue * queue)$/;"	f	class:simlib3::Facility
Facility	simlib.h	/^class Facility : public SimObject {$/;"	c	namespace:simlib3
FacilityRefError	errors.h	/^\/* 41 *\/ FacilityRefError,$/;"	e	enum:_ErrEnum
First	cond.cc	/^aCondition *aCondition::First = 0;       \/\/ condition list$/;"	m	class:simlib3::aCondition	file:
First	graph.cc	/^Graph *Graph::First = 0;$/;"	m	class:simlib3::Graph	file:
First	sampler.cc	/^Sampler *Sampler::First = 0;$/;"	m	class:simlib3::Sampler	file:
First	simlib.h	/^    static Sampler *First;              \/\/ list of objects TODO: use container$/;"	m	class:simlib3::Sampler
First	simlib.h	/^  static aCondition *First;            \/\/ list of all conditions$/;"	m	class:simlib3::aCondition
FirstIntegrator	simlib.h	/^  static Iterator FirstIntegrator(void) {  \/\/ it. to first integrator in list$/;"	f	class:simlib3::IntegrationMethod
FirstStatus	simlib.h	/^  static StatusIterator FirstStatus(void) {  \/\/ it. to first status in list$/;"	f	class:simlib3::StatusMethod
Free	simlib.h	/^  unsigned long Free() const { return capacity - used; }\/\/!< free capacity$/;"	f	class:simlib3::Store
Frict	simlib.h	/^class Frict : public aContiBlock1 {$/;"	c	namespace:simlib3
Frict	stdblock.cc	/^Frict::Frict(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Frict
Friction	simlib.h	/^typedef Frict Friction;$/;"	t	namespace:simlib3
Full	simlib.h	/^  bool Full() const   { return Free() == 0; }           \/\/!< store is full$/;"	f	class:simlib3::Store
FunCall	numint.cc	/^void IntegrationMethod::FunCall(double step_frag)$/;"	f	class:simlib3::IntegrationMethod
Function1	fun.cc	/^Function1::Function1(Input i, double (*pf)(double))$/;"	f	class:simlib3::Function1
Function1	simlib.h	/^class Function1 : public aContiBlock1 {$/;"	c	namespace:simlib3
Function2	fun.cc	/^Function2::Function2(Input i1, Input i2, double (*pf)(double,double))$/;"	f	class:simlib3::Function2
Function2	simlib.h	/^class Function2 : public aContiBlock2 {$/;"	c	namespace:simlib3
Gamma	random2.cc	/^double Gamma(double alfa, double beta)$/;"	f	namespace:simlib3
GenEnum	generr.c	/^void GenEnum(FILE * outf, TABLE * t)$/;"	f
GenErrFun	generr.c	/^void GenErrFun(FILE * outf)$/;"	f
GenMessages	generr.c	/^void GenMessages(FILE * outf, TABLE * t)$/;"	f
GenerHeader	generr.c	/^void GenerHeader(TABLE * t)$/;"	f
GenerModule	generr.c	/^void GenerModule(TABLE * t)$/;"	f
Geom	random2.cc	/^int Geom(double q)$/;"	f	namespace:simlib3
GeomError	errors.h	/^\/* 56 *\/ GeomError,$/;"	e	enum:_ErrEnum
Get	calendar.cc	/^Entity * CalendarList::Get(Entity * e)$/;"	f	class:simlib3::CalendarList
Get	calendar.cc	/^Entity * CalendarQueue::Get(Entity * e)$/;"	f	class:simlib3::CalendarQueue
Get	calendar.cc	/^void SQS::Get(Entity *e) {             \/\/ used by Run() only$/;"	f	class:simlib3::SQS
Get	list.cc	/^Link *List::Get(iterator pos)$/;"	f	class:simlib3::List
Get	queue.cc	/^Entity *Queue::Get(iterator pos)$/;"	f	class:simlib3::Queue
GetChar	generr.c	/^int GetChar(void)$/;"	f
GetCurrent	waitunti.cc	/^void WaitUntilList::GetCurrent()$/;"	f	class:simlib3::WaitUntilList
GetDiff	simlib.h	/^  double GetDiff(void) { return dd; }$/;"	f	class:simlib3::Integrator
GetErrId	generr.c	/^char *GetErrId(void)$/;"	f
GetErrMsg	generr.c	/^char *GetErrMsg(void)$/;"	f
GetErrNo	simlib.h	/^  static int GetErrNo(void) { \/\/ return # of errors$/;"	f	class:simlib3::IntegrationMethod
GetEventNotice	simlib.h	/^    EventNotice *GetEventNotice() { return _evn; }$/;"	f	class:simlib3::Entity
GetFirst	calendar.cc	/^Entity * CalendarQueue::GetFirst()$/;"	f	class:simlib3::CalendarQueue
GetFirst	calendar.cc	/^Entity *CalendarList::GetFirst()$/;"	f	class:simlib3::CalendarList
GetFirst	calendar.cc	/^Entity *SQS::GetFirst() {                  \/\/ used by Run()$/;"	f	class:simlib3::SQS
GetFirst	list.cc	/^Link *List::GetFirst()$/;"	f	class:simlib3::List
GetFirst	queue.cc	/^Entity *Queue::GetFirst()$/;"	f	class:simlib3::Queue
GetHeader	generr.c	/^void GetHeader(FILE * inf, char *funcname, char *enumname)$/;"	f
GetIdent	generr.c	/^void GetIdent(char *sptr)$/;"	f
GetLast	list.cc	/^Link *List::GetLast()$/;"	f	class:simlib3::List
GetLast	queue.cc	/^Entity *Queue::GetLast()$/;"	f	class:simlib3::Queue
GetLine	generr.c	/^int GetLine(FILE * inf)$/;"	f
GetMethod	simlib.h	/^  static const char* GetMethod(void) {  \/\/ get name of method which is used$/;"	f	class:simlib3::IntegrationMethod
GetMethod	simlib.h	/^inline const char* GetMethod(void)$/;"	f	namespace:simlib3
GetName	name.cc	/^const char *GetName(SimObject & o)$/;"	f	namespace:simlib3
GetName	name.cc	/^const char *GetName(SimObject * o)$/;"	f	namespace:simlib3
GetOldDiff	simlib.h	/^  double GetOldDiff(void) { return ddl; }$/;"	f	class:simlib3::Integrator
GetOldState	simlib.h	/^  double GetOldState(void) { return ssl; }$/;"	f	class:simlib3::Integrator
GetOldState	simlib.h	/^  double GetOldState(void) { return stl; }$/;"	f	class:simlib3::Status
GetStarter	numint.cc	/^const char* MultiStepMethod::GetStarter(const char* name)$/;"	f	class:simlib3::MultiStepMethod
GetStarter	simlib.h	/^inline const char* GetStarter(const char* name)$/;"	f	namespace:simlib3
GetStarter	simlib.h	/^inline const char* GetStarter(void)$/;"	f	namespace:simlib3
GetState	simlib.h	/^  double GetState(void) { return ss; }$/;"	f	class:simlib3::Integrator
GetState	simlib.h	/^  double GetState(void) { return st; }$/;"	f	class:simlib3::Status
GetStep	simlib.h	/^    double GetStep() const { return step; } \/\/!< get current step$/;"	f	class:simlib3::Sampler
GetTable	generr.c	/^void GetTable(FILE * inf, TABLE * t)$/;"	f
GoToState	numint.cc	/^void StatusMethod::GoToState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod
Graph	graph.cc	/^Graph::Graph(char *_name, Input i, double dTime) : in(i), TimeStep(dTime)$/;"	f	class:simlib3::Graph
GraphRefError	errors.h	/^\/* 31 *\/ GraphRefError,$/;"	e	enum:_ErrEnum
HIGHEST_PRIORITY	simlib.h	/^  HIGHEST_PRIORITY = 127,$/;"	e	enum:simlib3::__anon4
HOOK_INST_NAME	internal.h	228;"	d
HOOK_PTR_NAME	internal.h	227;"	d
HasName	simlib.h	/^  bool HasName() const { return _name !=0; }$/;"	f	class:simlib3::SimObject
Height	simlib.h	/^  unsigned Height() const { return maxn; }      \/\/!< barrier size$/;"	f	class:simlib3::Barrier
High	simlib.h	/^  double High() const    { return low + step*count; }$/;"	f	class:simlib3::Histogram
HistoCountError	errors.h	/^\/* 25 *\/ HistoCountError,$/;"	e	enum:_ErrEnum
HistoRefError	errors.h	/^\/* 23 *\/ HistoRefError,$/;"	e	enum:_ErrEnum
HistoStepError	errors.h	/^\/* 24 *\/ HistoStepError,$/;"	e	enum:_ErrEnum
Histogram	histo.cc	/^Histogram::Histogram() :         \/\/ ???$/;"	f	class:simlib3::Histogram
Histogram	histo.cc	/^Histogram::Histogram(const char *n, double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram
Histogram	histo.cc	/^Histogram::Histogram(double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram
Histogram	simlib.h	/^class Histogram : public SimObject {$/;"	c	namespace:simlib3
HyperGeom	random2.cc	/^int HyperGeom(double p, int n, int m)$/;"	f	namespace:simlib3
HyperGeomError1	errors.h	/^\/* 57 *\/ HyperGeomError1,$/;"	e	enum:_ErrEnum
HyperGeomError2	errors.h	/^\/* 58 *\/ HyperGeomError2,$/;"	e	enum:_ErrEnum
Hyst	simlib.h	/^class Hyst : public Status {$/;"	c	namespace:simlib3
Hyst	stdblock.cc	/^Hyst::Hyst(Input i, double _p1, double _p2, double _y1, double _y2, double _tga)$/;"	f	class:simlib3::Hyst
Hysteresis	simlib.h	/^typedef Hyst Hysteresis; \/\/ alias name$/;"	t	namespace:simlib3
INICONST	random1.cc	/^const myint32 INICONST   = 1537L;$/;"	m	namespace:simlib3	file:
INITIALIZATION	internal.h	/^    INITIALIZATION, \/\/ after Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
INSTALL_HOOK	internal.h	236;"	d
Idle	simlib.h	/^    bool Idle() { return _evn==0; }     \/\/!< entity activation is not scheduled in calendar$/;"	f	class:simlib3::Entity
InconsistentHeader	errors.h	/^\/* 66 *\/ InconsistentHeader,$/;"	e	enum:_ErrEnum
Init	atexit.cc	/^int SIMLIB_module::Init(const char *s) {$/;"	f	class:simlib3::SIMLIB_module
Init	barrier.cc	/^void Barrier::Init() {$/;"	f	class:simlib3::Barrier
Init	cond.cc	/^void Condition::Init()$/;"	f	class:simlib3::Condition
Init	delay.cc	/^void Delay::Init() {$/;"	f	class:simlib3::Delay
Init	histo.cc	/^void Histogram::Init(double l, double s, unsigned c)$/;"	f	class:simlib3::Histogram
Init	intg.cc	/^void Integrator::Init(double initvalue) {$/;"	f	class:simlib3::Integrator
Init	intg.cc	/^void Status::Init(double initvalue)$/;"	f	class:simlib3::Status
Init	run.cc	/^void SIMLIB_statistics_t::Init() {$/;"	f	class:simlib3::SIMLIB_statistics_t
Init	simlib.h	/^  void Init() { Init(initval); }       \/\/!< use preset initial value$/;"	f	class:simlib3::Integrator
Init	simlib.h	/^  void Init() { Init(initval); }$/;"	f	class:simlib3::Status
Init	simlib.h	/^inline void Init(double t0, double t1=SIMLIB_MAXTIME) {$/;"	f	namespace:simlib3
Init	simlib3D.h	/^  void Init(const Value3D &v) {_x.Init(v.x()); _y.Init(v.y()); _z.Init(v.z());}$/;"	f	class:simlib3::Integrator3D
Init	zdelay.cc	/^void ZDelay::Init() {$/;"	f	class:simlib3::ZDelay
Init	zdelay.cc	/^void ZDelay::Init(double iv) { \/\/ set initial value of ZDelay block$/;"	f	class:simlib3::ZDelay
Init	zdelay.cc	/^void ZDelayTimer::Init()  \/\/ called each Run()$/;"	f	class:simlib3::ZDelayTimer
InitAll	cond.cc	/^void aCondition::InitAll() {$/;"	f	class:simlib3::aCondition
InitAll	delay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_Delay	file:
InitAll	intg.cc	/^void IntegratorContainer::InitAll()$/;"	f	class:simlib3::IntegratorContainer
InitAll	intg.cc	/^void StatusContainer::InitAll()$/;"	f	class:simlib3::StatusContainer
InitAll	sampler.cc	/^void Sampler::InitAll() {$/;"	f	class:simlib3::Sampler
InitAll	zdelay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:
InitError	errors.h	/^\/* 4 *\/ InitError,$/;"	e	enum:_ErrEnum
InitInRunError	errors.h	/^\/* 6 *\/ InitInRunError,$/;"	e	enum:_ErrEnum
InitMinStepError	errors.h	/^\/* 9 *\/ InitMinStepError,$/;"	e	enum:_ErrEnum
InitStep	numint.cc	/^void IntegrationMethod::InitStep(double step_frag)$/;"	f	class:simlib3::IntegrationMethod
InitTable	generr.c	/^void InitTable(TABLE ** t)$/;"	f
Initialize	delay.cc	/^    static void Initialize() {          \/\/ initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_Delay	file:
Initialize	graph.cc	/^void Graph::Initialize()$/;"	f	class:simlib3::Graph
Initialize	zdelay.cc	/^    static void Initialize() {          \/\/ initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:
Input	simlib.h	/^  Input(aContiBlock &cb): bp(&cb) { RegisterReference(bp); } \/\/!< reference to block$/;"	f	class:simlib3::Input
Input	simlib.h	/^  Input(aContiBlock *cb): bp(cb)  { RegisterReference(bp); } \/\/!< pointer to block$/;"	f	class:simlib3::Input
Input	simlib.h	/^  Input(const Input &i): bp(i.bp) { RegisterReference(bp); }$/;"	f	class:simlib3::Input
Input	simlib.h	/^  Input(const double c):  bp(new Constant(c)) { RegisterReference(bp); }$/;"	f	class:simlib3::Input
Input	simlib.h	/^class Input {$/;"	c	namespace:simlib3
Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2
Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3
Input1Value	simlib2D.h	/^  Value2D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2D2
Input1Value	simlib3D.h	/^  Value3D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3D2
Input2D	simlib2D.h	/^  Input2D(aContiBlock2D &cb): bp(&cb) {}         \/\/ reference to 2D block$/;"	f	class:simlib3::Input2D
Input2D	simlib2D.h	/^  Input2D(aContiBlock2D *cb): bp(cb)  {}         \/\/ pointer to 2D block$/;"	f	class:simlib3::Input2D
Input2D	simlib2D.h	/^  Input2D(const Input2D &in): bp(in.bp) {}       \/\/ copy reference$/;"	f	class:simlib3::Input2D
Input2D	simlib2D.h	/^class Input2D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2
Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3
Input2Value	simlib2D.h	/^  Value2D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2D2
Input2Value	simlib3D.h	/^  Value3D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3D2
Input3D	simlib3D.h	/^  Input3D(aContiBlock3D &cb): bp(&cb) {}          \/\/ reference to 3D block$/;"	f	class:simlib3::Input3D
Input3D	simlib3D.h	/^  Input3D(aContiBlock3D *cb): bp(cb)  {}          \/\/ pointer to 3D block$/;"	f	class:simlib3::Input3D
Input3D	simlib3D.h	/^  Input3D(const Input3D &inp): bp(inp.bp) {}      \/\/ copy reference$/;"	f	class:simlib3::Input3D
Input3D	simlib3D.h	/^class Input3D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
Input3Value	simlib.h	/^  double Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3
Input3Value	simlib2D.h	/^  Value2D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock2D3
Input3Value	simlib3D.h	/^  Value3D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3D3
InputValue	simlib.h	/^  double InputValue() { return input.Value(); } \/\/!< current input value$/;"	f	class:simlib3::Integrator
InputValue	simlib.h	/^  double InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock1
InputValue	simlib2D.h	/^  Value2D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock2D1
InputValue	simlib3D.h	/^  Value3D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock3D1
InsFirst	list.cc	/^void List::InsFirst(Link *ent)$/;"	f	class:simlib3::List
InsFirst	queue.cc	/^void Queue::InsFirst(Entity *ent)$/;"	f	class:simlib3::Queue
InsLast	list.cc	/^void List::InsLast(Link *ent)$/;"	f	class:simlib3::List
InsLast	queue.cc	/^void Queue::InsLast(Entity *ent)$/;"	f	class:simlib3::Queue
Insert	intg.cc	/^IntegratorContainer::iterator IntegratorContainer::Insert(Integrator* ptr)$/;"	f	class:simlib3::IntegratorContainer
Insert	intg.cc	/^StatusContainer::iterator StatusContainer::Insert(Status* ptr)$/;"	f	class:simlib3::StatusContainer
Insert	queue.cc	/^void Queue::Insert(Entity *ent)$/;"	f	class:simlib3::Queue
InsertCurrent	waitunti.cc	/^void WaitUntilList::InsertCurrent()$/;"	f	class:simlib3::WaitUntilList
InstallBreak	run.cc	/^void InstallBreak(void (*f)()) { \/\/ for user interface (in simlib.h)$/;"	f	namespace:simlib3
Instance	intg.cc	/^std::list<Integrator*>* IntegratorContainer::Instance(void)$/;"	f	class:simlib3::IntegratorContainer
Instance	intg.cc	/^std::list<Status*>* StatusContainer::Instance(void)$/;"	f	class:simlib3::StatusContainer
Insv	simlib.h	/^class Insv : public aContiBlock1 {$/;"	c	namespace:simlib3
Insv	stdblock.cc	/^Insv::Insv(Input in, double l, double h, double tga, double tgb)$/;"	f	class:simlib3::Insv
Integrate	ni_abm4.cc	/^void ABM4::Integrate(void)$/;"	f	class:simlib3::ABM4
Integrate	ni_euler.cc	/^void EULER::Integrate(void)$/;"	f	class:simlib3::EULER
Integrate	ni_fw.cc	/^void FW::Integrate(void)$/;"	f	class:simlib3::FW
Integrate	ni_rke.cc	/^void RKE::Integrate(void)$/;"	f	class:simlib3::RKE
Integrate	ni_rkf3.cc	/^void RKF3::Integrate(void)$/;"	f	class:simlib3::RKF3
Integrate	ni_rkf5.cc	/^void RKF5::Integrate(void)$/;"	f	class:simlib3::RKF5
Integrate	ni_rkf8.cc	/^void RKF8::Integrate(void)$/;"	f	class:simlib3::RKF8
IntegrationDone	simlib.h	/^  static void IntegrationDone(void) {  \/\/ terminate integration$/;"	f	class:simlib3::IntegrationMethod
IntegrationMethod	numint.cc	/^IntegrationMethod::IntegrationMethod(const char *name):$/;"	f	class:simlib3::IntegrationMethod
IntegrationMethod	simlib.h	/^class IntegrationMethod {$/;"	c	namespace:simlib3
Integrator	intg.cc	/^Integrator::Integrator() : input(SIMLIB_Integrator_0input)$/;"	f	class:simlib3::Integrator
Integrator	intg.cc	/^Integrator::Integrator(Input i, double initvalue) : input(i)$/;"	f	class:simlib3::Integrator
Integrator	intg.cc	/^Integrator::Integrator(Integrator &i, double initvalue) :$/;"	f	class:simlib3::Integrator
Integrator	simlib.h	/^class Integrator : public aContiBlock {   \/\/ integrator$/;"	c	namespace:simlib3
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D():$/;"	f	class:simlib3::Integrator2D
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i):$/;"	f	class:simlib3::Integrator2D
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Integrator2D &i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D
Integrator2D	simlib2D.h	/^class Integrator2D : public aContiBlock2D {$/;"	c	namespace:simlib3
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D():$/;"	f	class:simlib3::Integrator3D
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i):$/;"	f	class:simlib3::Integrator3D
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Integrator3D &i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D
Integrator3D	simlib3D.h	/^class Integrator3D : public aContiBlock3D {$/;"	c	namespace:simlib3
IntegratorContainer	simlib.h	/^class IntegratorContainer {$/;"	c	namespace:simlib3
InternalError	errors.h	/^\/* 2 *\/ InternalError,$/;"	e	enum:_ErrEnum
Interrupt	process.cc	/^void Process::Interrupt()$/;"	f	class:simlib3::Process
Into	link.cc	/^void Link::Into(List *l)$/;"	f	class:simlib3::Link
Into	process.cc	/^void Process::Into(Queue & q)$/;"	f	class:simlib3::Process
IsConditionFlag	simlib.h	/^  static bool IsConditionFlag(void) { \/\/ wer any changes of condition vector?$/;"	f	class:simlib3::IntegrationMethod
IsEndStepEvent	numint.cc	/^bool IntegrationMethod::IsEndStepEvent=false;$/;"	m	class:simlib3::IntegrationMethod	file:
IsEndStepEvent	simlib.h	/^  static bool IsEndStepEvent; \/\/ flag - will be event at the end of the step?$/;"	m	class:simlib3::IntegrationMethod
IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a multi-step method$/;"	f	class:simlib3::MultiStepMethod
IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a single-step method$/;"	f	class:simlib3::SingleStepMethod
IsStartMode	simlib.h	/^  bool IsStartMode(void) {  \/\/ is method used to start multi-step method?$/;"	f	class:simlib3::SingleStepMethod
ItList	simlib.h	/^  std::list<IntegrationMethod*>::iterator ItList;  \/\/ position in the list$/;"	m	class:simlib3::IntegrationMethod
Iterate	numint.cc	/^void IntegrationMethod::Iterate(void)$/;"	f	class:simlib3::IntegrationMethod
Iterations	simlib.h	/^  Iterations(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Iterations
Iterations	simlib.h	/^class Iterations : public AlgLoop {$/;"	c	namespace:simlib3
Iterator	simlib.h	/^  typedef IntegratorContainer::iterator Iterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::IntegrationMethod
LIST_MAX	calendar.cc	/^const unsigned LIST_MAX   = 512; \/\/ TODO:tune parameter: 64-1024$/;"	m	namespace:simlib3	file:
LIST_MIN	calendar.cc	/^const unsigned LIST_MIN   = LIST_MAX\/2; \/\/ TODO:tune parameter$/;"	m	namespace:simlib3	file:
LOWEST_PRIORITY	simlib.h	/^  LOWEST_PRIORITY  = -127,$/;"	e	enum:simlib3::__anon4
LastIntegrator	simlib.h	/^  static Iterator LastIntegrator(void) {  \/\/ it. to last integrator in list$/;"	f	class:simlib3::IntegrationMethod
LastStatus	simlib.h	/^  static StatusIterator LastStatus(void) {  \/\/ it. to last status in list$/;"	f	class:simlib3::StatusMethod
LastTime	simlib.h	/^  double LastTime() const      { return tl; }$/;"	f	class:simlib3::TStat
LastValue	simlib.h	/^  double LastValue() const     { return xl; }$/;"	f	class:simlib3::TStat
Leave	process.cc	/^void Process::Leave(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process
Leave	store.cc	/^void Store::Leave(unsigned long rcap)$/;"	f	class:simlib3::Store
LeaveManyError	errors.h	/^\/* 47 *\/ LeaveManyError,$/;"	e	enum:_ErrEnum
Length	simlib.h	/^    unsigned Length() { return size(); }$/;"	f	class:simlib3::Queue
Lim	simlib.h	/^class Lim : public aContiBlock1 {$/;"	c	namespace:simlib3
Lim	stdblock.cc	/^Lim::Lim(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Lim
Limitation	simlib.h	/^typedef Lim Limitation;$/;"	t	namespace:simlib3
Link	link.cc	/^Link::Link() :$/;"	f	class:simlib3::Link
Link	link.cc	/^Link::Link(Link *p, Link *s, List *h) :$/;"	f	class:simlib3::Link
Link	simlib.h	/^class Link : public SimObject {$/;"	c	namespace:simlib3
LinkDelError	errors.h	/^\/* 15 *\/ LinkDelError,$/;"	e	enum:_ErrEnum
LinkOutError	errors.h	/^\/* 16 *\/ LinkOutError,$/;"	e	enum:_ErrEnum
LinkRefError	errors.h	/^\/* 14 *\/ LinkRefError,$/;"	e	enum:_ErrEnum
List	list.cc	/^List::List() : Link(this,this,this), n(0)$/;"	f	class:simlib3::List
List	list.cc	/^List::List(const char *name) : Link(this,this,this), n(0)$/;"	f	class:simlib3::List
List	simlib.h	/^class List : public Link { \/\/ circular list of Link items$/;"	c	namespace:simlib3
ListActivityError	errors.h	/^\/* 27 *\/ ListActivityError,$/;"	e	enum:_ErrEnum
ListEmptyError	errors.h	/^\/* 28 *\/ ListEmptyError,$/;"	e	enum:_ErrEnum
ListPtr	intg.cc	/^std::list<Integrator*>* IntegratorContainer::ListPtr=NULL;$/;"	m	class:simlib3::IntegratorContainer	file:
ListPtr	intg.cc	/^std::list<Status*>* StatusContainer::ListPtr=NULL;$/;"	m	class:simlib3::StatusContainer	file:
ListPtr	simlib.h	/^      std::list<Memory*> * ListPtr;  \/\/ which list is memory in$/;"	m	class:simlib3::IntegrationMethod::Memory
ListPtr	simlib.h	/^  static std::list<Integrator*> * ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::IntegratorContainer
ListPtr	simlib.h	/^  static std::list<Status*>* ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::StatusContainer
ListRefError	errors.h	/^\/* 26 *\/ ListRefError,$/;"	e	enum:_ErrEnum
Ln	fun.cc	/^Input Ln(Input x)               { return new Function1(x, log); }$/;"	f	namespace:simlib3
Log10	fun.cc	/^Input Log10(Input x)            { return new Function1(x, log10); }$/;"	f	namespace:simlib3
Logar	random2.cc	/^double Logar(double mi, double delta)$/;"	f	namespace:simlib3
Low	simlib.h	/^  double Low() const     { return low; }$/;"	f	class:simlib3::Histogram
LowGreaterHigh	errors.h	/^\/* 64 *\/ LowGreaterHigh,$/;"	e	enum:_ErrEnum
LtoN	intg.cc	/^void IntegratorContainer::LtoN()$/;"	f	class:simlib3::IntegratorContainer
LtoN	intg.cc	/^void StatusContainer::LtoN()$/;"	f	class:simlib3::StatusContainer
MAXERR	generr.c	13;"	d	file:
MAXHISTOCOUNT	histo.cc	/^const unsigned MAXHISTOCOUNT = 10000;$/;"	m	namespace:simlib3	file:
MAXIDLEN	generr.c	14;"	d	file:
MAXLINELEN	generr.c	15;"	d	file:
MAXLONGINT	random1.cc	/^const myint32 MAXLONGINT = 0x7FFFFFFFUL;$/;"	m	namespace:simlib3	file:
MAXSIZELIMIT	calendar.cc	/^    static const unsigned MAXSIZELIMIT = 1000000;$/;"	m	class:simlib3::EventNoticeAllocator	file:
MAX_ATEXIT	atexit.cc	/^static const int MAX_ATEXIT = 10; \/\/ for internal use it is enough$/;"	m	namespace:simlib3	file:
MAX_OP	calendar.cc	614;"	d	file:
MINBUCKETS	calendar.cc	/^const unsigned MINBUCKETS = LIST_MAX>4?LIST_MAX:4; \/\/ should be power of 2 and >=4$/;"	m	namespace:simlib3	file:
MList	simlib.h	/^  std::list<Memory*> MList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::IntegrationMethod
MULCONST	random1.cc	/^const myint32 MULCONST   = 1220703125L;$/;"	m	namespace:simlib3	file:
MUL_PAR	calendar.cc	/^const double MUL_PAR      = 1.0; \/\/ TODO:tune parameter: 1.0--5.0$/;"	m	namespace:simlib3	file:
Max	fun.cc	/^Input Max(Input x, Input y)     { return new Function2(x, y, max); }$/;"	f	namespace:simlib3
Max	optimize.h	/^    double Max() const { return max; }$/;"	f	class:simlib3::Param
Max	simlib.h	/^  double Max() const           { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::Stat
Max	simlib.h	/^  double Max() const           { return max; }$/;"	f	class:simlib3::TStat
Max	simlib.h	/^  double Max() const { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::aStat
MaxIt	simlib.h	/^  unsigned long MaxIt; \/\/ max. number of iterations$/;"	m	class:simlib3::AlgLoop
MaxStep	intg.cc	/^const double &MaxStep=SIMLIB_MaxStep;        \/\/!< maximal integration step$/;"	m	namespace:simlib3	file:
MaxStep	simlib.h	/^  double MaxStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t
MeanValue	stat.cc	/^double Stat::MeanValue() const$/;"	f	class:simlib3::Stat
MeanValue	tstat.cc	/^double TStat::MeanValue() const$/;"	f	class:simlib3::TStat
Memory	numint.cc	/^IntegrationMethod::Memory::Memory(std::list<Memory*>* PtrList) :$/;"	f	class:simlib3::IntegrationMethod::Memory
Memory	simlib.h	/^  class Memory {$/;"	c	class:simlib3::IntegrationMethod
MemoryError	errors.h	/^\/* 3 *\/ MemoryError,$/;"	e	enum:_ErrEnum
Min	fun.cc	/^Input Min(Input x, Input y)     { return new Function2(x, y, min); }$/;"	f	namespace:simlib3
Min	optimize.h	/^    double Min() const { return min; }$/;"	f	class:simlib3::Param
Min	simlib.h	/^  double Min() const           { \/* TODO: test n==0 *\/ return min; }$/;"	f	class:simlib3::Stat
Min	simlib.h	/^  double Min() const           { \/*TODO: only if(n>0)*\/ return min; }$/;"	f	class:simlib3::TStat
Min	simlib.h	/^  double Min() const { \/* test n==0 +exception *\/ return min; }$/;"	f	class:simlib3::aStat
MinStep	intg.cc	/^const double &MinStep=SIMLIB_MinStep;        \/\/!< minimal integration step$/;"	m	namespace:simlib3	file:
MinStep	simlib.h	/^  double MinStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t
MinTime	calendar.cc	/^    double MinTime() const { return mintime; }$/;"	f	class:simlib3::Calendar
MthLstPtr	numint.cc	/^std::list<IntegrationMethod*>* IntegrationMethod::MthLstPtr=NULL;$/;"	m	class:simlib3::IntegrationMethod	file:
MthLstPtr	simlib.h	/^  static std::list<IntegrationMethod*>* MthLstPtr; \/\/ list of registrated methods$/;"	m	class:simlib3::IntegrationMethod
MultiStepMethod	numint.cc	/^MultiStepMethod::MultiStepMethod(const char* name, const char* slave_name) :$/;"	f	class:simlib3::MultiStepMethod
MultiStepMethod	simlib.h	/^class MultiStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3
MyStrDup	generr.c	/^char *MyStrDup(char *sp)$/;"	f
NI_CantSetMethod	errors.h	/^\/* 81 *\/ NI_CantSetMethod,$/;"	e	enum:_ErrEnum
NI_CantSetStarter	errors.h	/^\/* 82 *\/ NI_CantSetStarter,$/;"	e	enum:_ErrEnum
NI_IlStepSize	errors.h	/^\/* 78 *\/ NI_IlStepSize,$/;"	e	enum:_ErrEnum
NI_MultDefMeth	errors.h	/^\/* 77 *\/ NI_MultDefMeth,$/;"	e	enum:_ErrEnum
NI_NotMultiStep	errors.h	/^\/* 80 *\/ NI_NotMultiStep,$/;"	e	enum:_ErrEnum
NI_NotSingleStep	errors.h	/^\/* 79 *\/ NI_NotSingleStep,$/;"	e	enum:_ErrEnum
NI_UnknownMeth	errors.h	/^\/* 76 *\/ NI_UnknownMeth,$/;"	e	enum:_ErrEnum
Name	algloop.cc	/^const char *AlgLoop::Name() const$/;"	f	class:simlib3::AlgLoop
Name	calendar.cc	/^    virtual const char* Name() { return "CalendarList"; }$/;"	f	class:simlib3::CalendarList
Name	calendar.cc	/^    virtual const char* Name() { return "CalendarQueue"; }$/;"	f	class:simlib3::CalendarQueue
Name	cond.cc	/^const char *Condition::Name() const {$/;"	f	class:simlib3::Condition
Name	cond.cc	/^const char *ConditionDown::Name() const {$/;"	f	class:simlib3::ConditionDown
Name	cond.cc	/^const char *ConditionUp::Name() const {$/;"	f	class:simlib3::ConditionUp
Name	continuous.cc	/^  virtual const char *Name() const { return "T(Time)"; }$/;"	f	class:simlib3::_Time
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Add
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Div
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Mul
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Sub
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_UMinus
Name	entity.cc	/^const char *Entity::Name() const$/;"	f	class:simlib3::Entity
Name	event.cc	/^const char *Event::Name() const$/;"	f	class:simlib3::Event
Name	fun.cc	/^const char *Function1::Name() const {$/;"	f	class:simlib3::Function1
Name	fun.cc	/^const char *Function2::Name() const {$/;"	f	class:simlib3::Function2
Name	intg.cc	/^const char *Integrator::Name() const$/;"	f	class:simlib3::Integrator
Name	intg.cc	/^const char *Status::Name() const$/;"	f	class:simlib3::Status
Name	object.cc	/^const char *SimObject::Name() const$/;"	f	class:simlib3::SimObject
Name	optimize.h	/^    const char *Name() const { return name; }$/;"	f	class:simlib3::Param
Name	process.cc	/^const char *Process::Name() const$/;"	f	class:simlib3::Process
Name	queue.cc	/^const char *Queue::Name() const$/;"	f	class:simlib3::Queue
Name	stdblock.cc	/^const char *Blash::Name() const$/;"	f	class:simlib3::Blash
Name	stdblock.cc	/^const char *Frict::Name() const$/;"	f	class:simlib3::Frict
Name	stdblock.cc	/^const char *Hyst::Name() const$/;"	f	class:simlib3::Hyst
Name	stdblock.cc	/^const char *Insv::Name() const$/;"	f	class:simlib3::Insv
Name	stdblock.cc	/^const char *Lim::Name() const$/;"	f	class:simlib3::Lim
Name	stdblock.cc	/^const char *Qntzr::Name() const$/;"	f	class:simlib3::Qntzr
Name	stdblock.cc	/^const char *Relay::Name() const$/;"	f	class:simlib3::Relay
Name	stdblock.cc	/^const char *Rline::Name() const$/;"	f	class:simlib3::Rline
NegBin	random2.cc	/^int NegBin(double q, int k)$/;"	f	namespace:simlib3
NegBinError	errors.h	/^\/* 52 *\/ NegBinError,$/;"	e	enum:_ErrEnum
NegBinM	random2.cc	/^int NegBinM(double p, int m)$/;"	f	namespace:simlib3
NegBinMError1	errors.h	/^\/* 53 *\/ NegBinMError1,$/;"	e	enum:_ErrEnum
NegBinMError2	errors.h	/^\/* 54 *\/ NegBinMError2,$/;"	e	enum:_ErrEnum
Newton	simlib.h	/^  Newton(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Newton
Newton	simlib.h	/^class Newton : public AlgLoop {$/;"	c	namespace:simlib3
Next	simlib.h	/^    Sampler *Next;                      \/\/ next object$/;"	m	class:simlib3::Sampler
Next	simlib.h	/^  aCondition *Next;                    \/\/ next condition in list$/;"	m	class:simlib3::aCondition
NextTime	run.cc	/^const double & NextTime  = SIMLIB_NextTime;     \/\/ next-event time$/;"	m	namespace:simlib3	file:
NoDebugErr	errors.h	/^\/* 85 *\/ NoDebugErr,$/;"	e	enum:_ErrEnum
NoError	generr.c	/^\/* 0 *\/ NoError,$/;"	e	enum:ErrEnum	file:
Normal	random2.cc	/^double Normal(double mi, double sigma)$/;"	f	namespace:simlib3
NtoL	intg.cc	/^void IntegratorContainer::NtoL()$/;"	f	class:simlib3::IntegratorContainer
NtoL	intg.cc	/^void StatusContainer::NtoL()$/;"	f	class:simlib3::StatusContainer
NumErr	generr.c	/^    unsigned NumErr;$/;"	m	struct:__anon1	file:
Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::Stat
Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::TStat
NumberOfRecords	simlib.h	/^  unsigned long NumberOfRecords() const { return n; }$/;"	f	class:simlib3::aStat
OP_ESTIMATE	calendar.cc	/^    OP_ESTIMATE=2,$/;"	e	enum:__anon2::__anon3	file:
OP_MEASURE	calendar.cc	/^int OP_MEASURE = 0;$/;"	m	namespace:__anon2	file:
OP_RESIZE	calendar.cc	/^    OP_RESIZE=1,$/;"	e	enum:__anon2::__anon3	file:
OP_SWITCH2CQ	calendar.cc	/^    OP_SWITCH2CQ=4,$/;"	e	enum:__anon2::__anon3	file:
OP_SWITCH2LIST	calendar.cc	/^    OP_SWITCH2LIST=8,$/;"	e	enum:__anon2::__anon3	file:
OpenInputFile	generr.c	/^FILE *OpenInputFile(char *name)$/;"	f
OpenOutputFile	generr.c	/^FILE *OpenOutputFile(char *name)$/;"	f
OptStep	intg.cc	/^const double &OptStep=SIMLIB_OptStep;        \/\/!< optimal integration step$/;"	m	namespace:simlib3	file:
Optimize_hooke	opt-hooke.cc	/^double Optimize_hooke(opt_function_t f, ParameterVector & parameter,$/;"	f	namespace:simlib3
Optimize_simann	opt-simann.cc	/^double Optimize_simann(double (*f) (const ParameterVector & p),$/;"	f	namespace:simlib3
Out	entity.cc	/^void Entity::Out()$/;"	f	class:simlib3::Entity
Out	link.cc	/^void Link::Out()$/;"	f	class:simlib3::Link
OutFile	print.cc	/^    static FILE *OutFile;$/;"	m	class:simlib3::_FileWrap	file:
OutFile	print.cc	/^FILE *_FileWrap::OutFile = 0;$/;"	m	class:simlib3::_FileWrap	file:
OutFile	print.cc	/^} OutFile;$/;"	m	namespace:simlib3	typeref:class:simlib3::_FileWrap	file:
OutFileOpenError	errors.h	/^\/* 60 *\/ OutFileOpenError,$/;"	e	enum:_ErrEnum
OutFilePutError	errors.h	/^\/* 59 *\/ OutFilePutError,$/;"	e	enum:_ErrEnum
Output	barrier.cc	/^void Barrier::Output() const {$/;"	f	class:simlib3::Barrier
Output	object.cc	/^void SimObject::Output() const$/;"	f	class:simlib3::SimObject
Output	output1.cc	/^void Event::Output()$/;"	f	class:simlib3::Event
Output	output1.cc	/^void List::Output()$/;"	f	class:simlib3::List
Output	output1.cc	/^void SIMLIB_statistics_t::Output() const$/;"	f	class:simlib3::SIMLIB_statistics_t
Output	output2.cc	/^void Facility::Output()$/;"	f	class:simlib3::Facility
Output	output2.cc	/^void Histogram::Output()$/;"	f	class:simlib3::Histogram
Output	output2.cc	/^void Process::Output()$/;"	f	class:simlib3::Process
Output	output2.cc	/^void Queue::Output()$/;"	f	class:simlib3::Queue
Output	output2.cc	/^void Stat::Output()$/;"	f	class:simlib3::Stat
Output	output2.cc	/^void Store::Output()$/;"	f	class:simlib3::Store
Output	output2.cc	/^void TStat::Output()$/;"	f	class:simlib3::TStat
Output	sampler.cc	/^void Sampler::Output()$/;"	f	class:simlib3::Sampler
Output	semaphor.cc	/^void Semaphore::Output() {$/;"	f	class:simlib3::Semaphore
OwnQueue	facility.cc	/^bool Facility::OwnQueue() const$/;"	f	class:simlib3::Facility
OwnQueue	store.cc	/^bool Store::OwnQueue()$/;"	f	class:simlib3::Store
P	semaphor.cc	/^void Semaphore::P()$/;"	f	class:simlib3::Semaphore
PRED	ni_abm4.h	/^  Memory PRED;  \/\/ auxiliary memories -- value of predictor$/;"	m	class:simlib3::ABM4
P_Context	process.cc	/^static P_Context_t *volatile P_Context = 0;      \/\/ temporary - process state$/;"	m	namespace:simlib3	file:
P_Context_t	process.cc	/^struct P_Context_t {$/;"	s	namespace:simlib3	file:
Pair	delay.cc	/^        Pair(double t, double v) : time(t), value(v) {}$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair
Pair	delay.cc	/^    struct Pair { \/\/ pair (t,val) for storing in buffer$/;"	s	class:simlib3::SIMLIB_DelayBuffer	file:
Param	optimize.h	/^    Param (const char *n, double a, double b):$/;"	f	class:simlib3::Param
Param	optimize.h	/^    Param():$/;"	f	class:simlib3::Param
Param	optimize.h	/^class Param$/;"	c	namespace:simlib3
Parameter	simlib.h	/^  Parameter(double x) : value(x) {}$/;"	f	class:simlib3::Parameter
Parameter	simlib.h	/^class Parameter : public aContiBlock {$/;"	c	namespace:simlib3
Parameter2D	simlib2D.h	/^  explicit Parameter2D(Value2D x=Value2D(0,0)) : Variable2D(x) {}$/;"	f	class:simlib3::Parameter2D
Parameter2D	simlib2D.h	/^class Parameter2D : public Variable2D {$/;"	c	namespace:simlib3
Parameter3D	simlib3D.h	/^  explicit Parameter3D(Value3D x=Value3D(0,0,0)) : Variable3D(x) {}$/;"	f	class:simlib3::Parameter3D
Parameter3D	simlib3D.h	/^class Parameter3D : public Variable3D {$/;"	c	namespace:simlib3
ParameterChangeErr	errors.h	/^\/* 87 *\/ ParameterChangeErr,$/;"	e	enum:_ErrEnum
ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(const ParameterVector & a):n(a.n),$/;"	f	class:simlib3::ParameterVector
ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(int sz, Param * a):$/;"	f	class:simlib3::ParameterVector
ParameterVector	optimize.h	/^class ParameterVector$/;"	c	namespace:simlib3
Passivate	entity.cc	/^void Entity::Passivate()$/;"	f	class:simlib3::Entity
Passivate	process.cc	/^void Process::Passivate()$/;"	f	class:simlib3::Process
Passivate	simlib.h	/^inline void Passivate(Entity *e) { e->Passivate(); }  \/\/!< passivate entity e$/;"	f	namespace:simlib3
Phase	run.cc	/^const SIMLIB_Phase_t & Phase = SIMLIB_Phase;    \/\/ read-only reference$/;"	m	namespace:simlib3	file:
Poisson	random2.cc	/^int Poisson(double lambda)$/;"	f	namespace:simlib3
PoissonError	errors.h	/^\/* 55 *\/ PoissonError,$/;"	e	enum:_ErrEnum
PostIns	list.cc	/^void List::PostIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List
PostIns	queue.cc	/^void Queue::PostIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue
Pow	fun.cc	/^Input Pow(Input x, Input y)     { return new Function2(x, y, pow); }$/;"	f	namespace:simlib3
PredIns	list.cc	/^void List::PredIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List
PredIns	queue.cc	/^void Queue::PredIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue
Prepare	numint.cc	/^bool IntegrationMethod::Prepare(void)$/;"	f	class:simlib3::IntegrationMethod
PrepareStep	ni_abm4.cc	/^bool ABM4::PrepareStep(void)$/;"	f	class:simlib3::ABM4
PrepareStep	ni_fw.cc	/^bool FW::PrepareStep(void)$/;"	f	class:simlib3::FW
PrepareStep	numint.cc	/^bool IntegrationMethod::PrepareStep(void)$/;"	f	class:simlib3::IntegrationMethod
PrepareStep	numint.cc	/^bool MultiStepMethod::PrepareStep(void)$/;"	f	class:simlib3::MultiStepMethod
PrepareStep	numint.cc	/^bool StatusMethod::PrepareStep(void)$/;"	f	class:simlib3::StatusMethod
PrevINum	simlib.h	/^  size_t PrevINum;  \/\/ # of integrators in previous step$/;"	m	class:simlib3::IntegrationMethod
PrevStatusNum	simlib.h	/^  size_t PrevStatusNum;  \/\/ # of status variables in previous step$/;"	m	class:simlib3::StatusMethod
Print	opt-param.cc	/^void Param::Print() const$/;"	f	class:simlib3::Param
Print	opt-param.cc	/^void ParameterVector::Print() const$/;"	f	class:simlib3::ParameterVector
Print	print.cc	/^int Print(const char *fmt, ...)$/;"	f	namespace:simlib3
Print	print.cc	/^int Print(const double x)$/;"	f	namespace:simlib3
Print	print.cc	/^int Print(const double x, const double y)$/;"	f	namespace:simlib3
Print	print.cc	/^int Print(const double x, const double y, const double z)$/;"	f	namespace:simlib3
Print	simlib2D.cc	/^void aContiBlock2D::Print() {$/;"	f	class:simlib3::aContiBlock2D
Print	simlib2D.h	/^  void Print() { ::Print(" %g %g ", _x, _y); }$/;"	f	class:simlib3::Value2D
Print	simlib2D.h	/^inline void Print(Value2D a) { a.Print(); }$/;"	f	namespace:simlib3
Print	simlib3D.cc	/^void aContiBlock3D::Print() {$/;"	f	class:simlib3::aContiBlock3D
Print	simlib3D.h	/^  void Print() { ::Print(" %g %g %g ", _x, _y, _z); }$/;"	f	class:simlib3::Value3D
Print	simlib3D.h	/^inline void Print(Value3D a) { a.Print(); }$/;"	f	namespace:simlib3
PrintValues	opt-param.cc	/^void ParameterVector::PrintValues() const$/;"	f	class:simlib3::ParameterVector
Priority	simlib.h	/^    Priority_t Priority;                \/\/!< priority of the entity$/;"	m	class:simlib3::Entity
Priority_t	simlib.h	/^    typedef EntityPriority_t Priority_t;$/;"	t	class:simlib3::Entity
Process	process.cc	/^Process::Process(Priority_t p) : Entity(p) {$/;"	f	class:simlib3::Process
Process	simlib.h	/^class Process : public Entity {$/;"	c	namespace:simlib3
ProcessNotInitialized	errors.h	/^\/* 22 *\/ ProcessNotInitialized,$/;"	e	enum:_ErrEnum
ProcessRefError	errors.h	/^\/* 21 *\/ ProcessRefError,$/;"	e	enum:_ErrEnum
ProcessStatus_t	simlib.h	/^  enum ProcessStatus_t {$/;"	g	class:simlib3::Process
PtrMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* IntegrationMethod::PtrMList;$/;"	m	class:simlib3::IntegrationMethod	file:
PtrMList	simlib.h	/^  static std::list<Memory*> * PtrMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::IntegrationMethod
PtrStatusMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* StatusMethod::PtrStatusMList;$/;"	m	class:simlib3::StatusMethod	file:
PtrStatusMList	simlib.h	/^  static std::list<Memory*>* PtrStatusMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::StatusMethod
Q	simlib.h	/^  Queue *Q;                     \/\/!< input queue$/;"	m	class:simlib3::Store
Q	simlib.h	/^  Queue Q;                                      \/\/!< internal quqeue$/;"	m	class:simlib3::Semaphore
Q1	simlib.h	/^  Queue  *Q1;                \/\/!< input queue$/;"	m	class:simlib3::Facility
Q2	simlib.h	/^  Queue  *Q2;                \/\/!< interrupted requests queue$/;"	m	class:simlib3::Facility
Qntzr	simlib.h	/^class Qntzr : public aContiBlock1 {$/;"	c	namespace:simlib3
Qntzr	stdblock.cc	/^Qntzr::Qntzr(Input in, double p) \/\/ p = quantiz. step$/;"	f	class:simlib3::Qntzr
Quantizer	simlib.h	/^typedef Qntzr Quantizer;$/;"	t	namespace:simlib3
Queue	queue.cc	/^Queue::Queue()$/;"	f	class:simlib3::Queue
Queue	queue.cc	/^Queue::Queue(const char *name)$/;"	f	class:simlib3::Queue
Queue	simlib.h	/^class Queue : public List { \/\/ don't inherit interface for now$/;"	c	namespace:simlib3
QueueIn	facility.cc	/^void Facility::QueueIn(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility
QueueIn	store.cc	/^void Store::QueueIn(Entity *e, unsigned long c)$/;"	f	class:simlib3::Store
QueueIn2	facility.cc	/^void Facility::QueueIn2(Entity * e)$/;"	f	class:simlib3::Facility
QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q->size(); }$/;"	f	class:simlib3::Store
QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q1->size(); }$/;"	f	class:simlib3::Facility
QueueRefError	errors.h	/^\/* 29 *\/ QueueRefError,$/;"	e	enum:_ErrEnum
RKE	ni_rke.h	/^  RKE(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKE
RKE	ni_rke.h	/^class RKE : public StatusMethod {$/;"	c	namespace:simlib3
RKF3	ni_rkf3.h	/^  RKF3(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF3
RKF3	ni_rkf3.h	/^class RKF3 : public SingleStepMethod {$/;"	c	namespace:simlib3
RKF5	ni_rkf5.h	/^  RKF5(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF5
RKF5	ni_rkf5.h	/^class RKF5 : public SingleStepMethod {$/;"	c	namespace:simlib3
RKF8	ni_rkf8.h	/^  RKF8(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF8
RKF8	ni_rkf8.h	/^class RKF8 : public SingleStepMethod {$/;"	c	namespace:simlib3
Random	random1.cc	/^double Random()$/;"	f	namespace:simlib3
RandomSeed	random1.cc	/^void RandomSeed(long seed)$/;"	f	namespace:simlib3
Range	optimize.h	/^    double Range() const { return max - min; }$/;"	f	class:simlib3::Param
Rayle	random2.cc	/^double Rayle(double delta)$/;"	f	namespace:simlib3
Register	delay.cc	/^    static void Register(Delay *p) {    \/\/ must be called by Delay ctr$/;"	f	class:simlib3::SIMLIB_Delay
Register	zdelay.cc	/^    static void Register(ZDelayTimer *p) { \/\/ called from ZDelayTimer constructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer
Register	zdelay.cc	/^void ZDelayTimer::Register(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer
RegisterReference	simlib.h	877;"	d
RegulaFalsi	simlib.h	/^  RegulaFalsi(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::RegulaFalsi
RegulaFalsi	simlib.h	/^class RegulaFalsi : public AlgLoop {$/;"	c	namespace:simlib3
RelativeError	intg.cc	/^const double &RelativeError=SIMLIB_RelativeError; \/\/!< max. rel. error$/;"	m	namespace:simlib3	file:
Relay	simlib.h	/^class Relay : public Status {   \/\/ general relay block$/;"	c	namespace:simlib3
Relay	stdblock.cc	/^Relay::Relay(Input i, double _p1, double _p2, double _p3, double _p4, double _y1, double _y2)$/;"	f	class:simlib3::Relay
Release	facility.cc	/^void Facility::Release(Entity * e)$/;"	f	class:simlib3::Facility
Release	process.cc	/^void Process::Release(Facility & f)$/;"	f	class:simlib3::Process
ReleaseError	errors.h	/^\/* 43 *\/ ReleaseError,$/;"	e	enum:_ErrEnum
ReleaseNotSeized	errors.h	/^\/* 44 *\/ ReleaseNotSeized,$/;"	e	enum:_ErrEnum
Remove	waitunti.cc	/^    static void Remove(Process *p) { \/\/ find and remove p$/;"	f	class:simlib3::WaitUntilList
RemoveName	name.cc	/^void RemoveName(SimObject & o)$/;"	f	namespace:simlib3
RemoveName	name.cc	/^void RemoveName(SimObject * o)$/;"	f	namespace:simlib3
Resize	calendar.cc	/^void CalendarQueue::Resize(int grow)  \/\/ TODO: is it better to use target size?$/;"	f	class:simlib3::CalendarQueue
Resize	numint.cc	/^void IntegrationMethod::Memory::Resize(size_t cs)$/;"	f	class:simlib3::IntegrationMethod::Memory
Resize	numint.cc	/^void IntegrationMethod::Resize(size_t size)$/;"	f	class:simlib3::IntegrationMethod
Restore	intg.cc	/^void Status::Restore()$/;"	f	class:simlib3::Status
Restore	simlib.h	/^  void Restore(void) { dd=ddl; ss=ssl; }  \/\/ restore saved status$/;"	f	class:simlib3::Integrator
RestoreState	numint.cc	/^void StatusMethod::RestoreState(double dthlf, Memory& di, Memory& si,$/;"	f	class:simlib3::StatusMethod
Rline	simlib.h	/^class Rline : public aContiBlock1 {$/;"	c	namespace:simlib3
Rline	stdblock.cc	/^Rline::Rline(Input in, int num, double *X, double *Y)$/;"	f	class:simlib3::Rline
RlineErr1	errors.h	/^\/* 83 *\/ RlineErr1,$/;"	e	enum:_ErrEnum
RlineErr2	errors.h	/^\/* 84 *\/ RlineErr2,$/;"	e	enum:_ErrEnum
Run	run.cc	/^void Run() {$/;"	f	namespace:simlib3
RunUseError	errors.h	/^\/* 7 *\/ RunUseError,$/;"	e	enum:_ErrEnum
SFunctionUseError	errors.h	/^\/* 12 *\/ SFunctionUseError,$/;"	e	enum:_ErrEnum
SIGNBIT	random1.cc	/^const myint32 SIGNBIT    = 0x80000000UL;$/;"	m	namespace:simlib3	file:
SIMLIB_AbsoluteError	intg.cc	/^double SIMLIB_AbsoluteError=0;       \/\/!< absolute error$/;"	m	namespace:simlib3	file:
SIMLIB_COMPILER	simlib.h	68;"	d
SIMLIB_COMPILER	simlib.h	74;"	d
SIMLIB_COMPILER	simlib.h	76;"	d
SIMLIB_COMPILER	simlib.h	82;"	d
SIMLIB_COPYRIGHT	simlib.h	11;"	d
SIMLIB_ConditionFlag	cond.cc	/^bool SIMLIB_ConditionFlag = false;       \/\/ condition vector changed$/;"	m	namespace:simlib3	file:
SIMLIB_ContinueInit	intg.cc	/^void SIMLIB_ContinueInit()$/;"	f	namespace:simlib3
SIMLIB_ContractStep	intg.cc	/^double  SIMLIB_ContractStep = SIMLIB_MAXTIME;    \/\/!< requested step size$/;"	m	namespace:simlib3	file:
SIMLIB_ContractStepFlag	intg.cc	/^bool SIMLIB_ContractStepFlag = false;     \/\/!< requests shorter step$/;"	m	namespace:simlib3	file:
SIMLIB_Current	run.cc	/^Entity *SIMLIB_Current = NULL;$/;"	m	namespace:simlib3	file:
SIMLIB_DEBUG	_test_.cc	4;"	d	file:
SIMLIB_Delay	delay.cc	/^class SIMLIB_Delay {$/;"	c	namespace:simlib3	file:
SIMLIB_DelayBuffer	delay.cc	/^    SIMLIB_DelayBuffer(): buf(), last_insert(-2,0) { \/*empty*\/ }$/;"	f	class:simlib3::SIMLIB_DelayBuffer
SIMLIB_DelayBuffer	delay.cc	/^class SIMLIB_DelayBuffer : public Delay::Buffer { \/\/ memory for delayed signal$/;"	c	namespace:simlib3	file:
SIMLIB_DeltaTime	intg.cc	/^double SIMLIB_DeltaTime;             \/\/!< Time-SIMLIB_StepStartTime$/;"	m	namespace:simlib3	file:
SIMLIB_DoActions	run.cc	/^void SIMLIB_DoActions()$/;"	f	namespace:simlib3
SIMLIB_DoConditions	cond.cc	/^void SIMLIB_DoConditions()$/;"	f	namespace:simlib3
SIMLIB_Dynamic	continuous.cc	/^void SIMLIB_Dynamic() \/\/ called each step$/;"	f	namespace:simlib3
SIMLIB_DynamicFlag	intg.cc	/^bool SIMLIB_DynamicFlag = false;          \/\/!< in dynamic section$/;"	m	namespace:simlib3	file:
SIMLIB_ERRNO	intg.cc	/^int SIMLIB_ERRNO=0;$/;"	m	namespace:simlib3	file:
SIMLIB_EndTime	run.cc	/^double SIMLIB_EndTime;         \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
SIMLIB_Entity_Count	entity.cc	/^static unsigned long SIMLIB_Entity_Count = 0L; \/\/ # of entities in model$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	algloop.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	atexit.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	barrier.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	calendar.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	cond.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	continuous.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	debug.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	delay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	entity.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	error.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	event.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	facility.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	fun.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	graph.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	histo.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	internal.h	119;"	d
SIMLIB_IMPLEMENTATION	intg.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	link.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	list.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	name.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_abm4.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_euler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_fw.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf3.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf5.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf8.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	numint.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	object.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-hooke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-param.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-simann.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	output1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	output2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	print.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	process.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	queue.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	random1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	random2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	run.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	sampler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	semaphor.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	simlib2D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	simlib3D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	stat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	stdblock.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	store.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	tstat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	version.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	waitunti.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	zdelay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_Init	run.cc	/^void SIMLIB_Init(double T0, double T1, unsigned version)$/;"	f	namespace:simlib3
SIMLIB_MAXTIME	simlib.h	/^const double SIMLIB_MAXTIME = 1.0e30; \/\/!< maximum time (1e30 works for float, too)$/;"	m	namespace:simlib3
SIMLIB_MINTIME	simlib.h	/^const double SIMLIB_MINTIME = 0.0;    \/\/!< minimal time value$/;"	m	namespace:simlib3
SIMLIB_MaxStep	intg.cc	/^double SIMLIB_MaxStep=1;             \/\/!< max. step$/;"	m	namespace:simlib3	file:
SIMLIB_MinStep	intg.cc	/^double SIMLIB_MinStep=1e-10;         \/\/!< minimal step$/;"	m	namespace:simlib3	file:
SIMLIB_NextTime	run.cc	/^double SIMLIB_NextTime;        \/\/ next-event time$/;"	m	namespace:simlib3	file:
SIMLIB_OptStep	intg.cc	/^double SIMLIB_OptStep;               \/\/!< optimal step$/;"	m	namespace:simlib3	file:
SIMLIB_Phase	run.cc	/^SIMLIB_Phase_t SIMLIB_Phase = START;$/;"	m	namespace:simlib3	file:
SIMLIB_Phase_t	internal.h	/^enum SIMLIB_Phase_t {$/;"	g	namespace:simlib3
SIMLIB_RandomBase	random1.cc	/^double SIMLIB_RandomBase()  \/\/ range <0..1)$/;"	f	namespace:simlib3
SIMLIB_RandomBasePtr	random1.cc	/^static double (*SIMLIB_RandomBasePtr)() = SIMLIB_RandomBase;$/;"	m	namespace:simlib3	file:
SIMLIB_RandomSeed	random1.cc	/^static myint32 SIMLIB_RandomSeed = INICONST ;$/;"	m	namespace:simlib3	file:
SIMLIB_RelativeError	intg.cc	/^double SIMLIB_RelativeError=0.001;   \/\/!< relative error$/;"	m	namespace:simlib3	file:
SIMLIB_ResetStatus	intg.cc	/^bool SIMLIB_ResetStatus = false;$/;"	m	namespace:simlib3	file:
SIMLIB_SYSTEM	simlib.h	67;"	d
SIMLIB_SYSTEM	simlib.h	72;"	d
SIMLIB_SYSTEM	simlib.h	81;"	d
SIMLIB_StartTime	run.cc	/^double SIMLIB_StartTime;       \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
SIMLIB_StepSize	intg.cc	/^double SIMLIB_StepSize;              \/\/!< actual step$/;"	m	namespace:simlib3	file:
SIMLIB_StepStartTime	intg.cc	/^double SIMLIB_StepStartTime;         \/\/!< last step time$/;"	m	namespace:simlib3	file:
SIMLIB_Time	run.cc	/^double SIMLIB_Time;            \/\/ simulation time$/;"	m	namespace:simlib3	file:
SIMLIB_VERSION	simlib.h	9;"	d
SIMLIB_WUClear	run.cc	/^void SIMLIB_WUClear() \/\/ should be removed -- ise CALL_HOOK instead$/;"	f	namespace:simlib3
SIMLIB_ZDelayTimer	zdelay.cc	/^class SIMLIB_ZDelayTimer {$/;"	c	namespace:simlib3	file:
SIMLIB_atexit	atexit.cc	/^void SIMLIB_atexit(SIMLIB_atexit_function_t p) {$/;"	f	namespace:simlib3
SIMLIB_atexit_call	atexit.cc	/^static void SIMLIB_atexit_call() {$/;"	f	namespace:simlib3
SIMLIB_atexit_function_t	internal.h	/^typedef void (*SIMLIB_atexit_function_t)();$/;"	t	namespace:simlib3
SIMLIB_create_tmp_name	name.cc	/^const char *SIMLIB_create_tmp_name(const char *fmt, ...)$/;"	f	namespace:simlib3
SIMLIB_debug_flag	debug.cc	/^unsigned long SIMLIB_debug_flag = 0UL; \/\/ default = no debugging$/;"	m	namespace:simlib3	file:
SIMLIB_error	error.cc	/^void SIMLIB_error(const char *fmt, ... )$/;"	f	namespace:simlib3
SIMLIB_error	error.cc	/^void SIMLIB_error(const char*filename, const int linenum)$/;"	f	namespace:simlib3
SIMLIB_error	error.cc	/^void SIMLIB_error(const enum _ErrEnum N)$/;"	f	namespace:simlib3
SIMLIB_experiment_no	run.cc	/^unsigned long SIMLIB_experiment_no = 0;$/;"	m	namespace:simlib3	file:
SIMLIB_internal_error	internal.h	148;"	d
SIMLIB_module	atexit.cc	/^SIMLIB_module::SIMLIB_module():$/;"	f	class:simlib3::SIMLIB_module
SIMLIB_module	internal.h	/^class SIMLIB_module { \/\/ internal class for SIMLIB cleanup (atexit)$/;"	c	namespace:simlib3
SIMLIB_module_id	internal.h	/^static SIMLIB_module SIMLIB_module_id;$/;"	m	namespace:simlib3
SIMLIB_old_debug_flags	simlib.h	/^static unsigned long SIMLIB_old_debug_flags = Debug(SIMLIB_DEBUG);$/;"	m	namespace:simlib3
SIMLIB_run_statistics	run.cc	/^static SIMLIB_statistics_t SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
SIMLIB_statistics	run.cc	/^const SIMLIB_statistics_t &SIMLIB_statistics = SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
SIMLIB_statistics_t	run.cc	/^SIMLIB_statistics_t::SIMLIB_statistics_t() {$/;"	f	class:simlib3::SIMLIB_statistics_t
SIMLIB_statistics_t	simlib.h	/^struct SIMLIB_statistics_t {$/;"	s	namespace:simlib3
SIMLIB_version	version.cc	/^const unsigned SIMLIB_version = __SIMLIB__;  \/\/!< library version$/;"	m	namespace:simlib3	file:
SIMLIB_version_string	version.cc	/^const char *SIMLIB_version_string() {$/;"	f	namespace:simlib3
SIMLIB_warning	error.cc	/^void SIMLIB_warning( const enum _ErrEnum N )$/;"	f	namespace:simlib3
SIMLIB_warning	error.cc	/^void SIMLIB_warning(const char *fmt, ... )$/;"	f	namespace:simlib3
SIMULATION	internal.h	/^    SIMULATION,     \/\/ inside Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
SQS	internal.h	/^namespace SQS {$/;"	n	namespace:simlib3
STACK_RESERVED	process.cc	412;"	d	file:
START	internal.h	/^    START,          \/\/ before first Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
START_T	calendar.cc	/^inline void START_T() {$/;"	f	namespace:__anon2
STOP_T	calendar.cc	/^inline double STOP_T() {$/;"	f	namespace:__anon2
Sample	_test_.cc	/^void Sample() {$/;"	f
Sample	delay.cc	/^void Delay::Sample()$/;"	f	class:simlib3::Delay
Sample	graph.cc	/^void Graph::Sample()$/;"	f	class:simlib3::Graph
Sample	sampler.cc	/^void Sampler::Sample()$/;"	f	class:simlib3::Sampler
SampleAll	delay.cc	/^    static void SampleAll() {   \/\/ called each continuous step (and more)$/;"	f	class:simlib3::SIMLIB_Delay	file:
SampleDelays	run.cc	/^void SampleDelays() { \/\/ used at step-wise changes !!!###$/;"	f	namespace:simlib3
SampleIn	zdelay.cc	/^void ZDelay::SampleIn()$/;"	f	class:simlib3::ZDelay
SampleOut	zdelay.cc	/^void ZDelay::SampleOut()$/;"	f	class:simlib3::ZDelay
Sampler	sampler.cc	/^Sampler::Sampler(void(*pf)(), double dt) :$/;"	f	class:simlib3::Sampler
Sampler	simlib.h	/^class Sampler: public Event {$/;"	c	namespace:simlib3
Save	simlib.h	/^  void Save() { stl = st; }            \/\/ save status$/;"	f	class:simlib3::Status
Save	simlib.h	/^  void Save(void) { ddl=dd; ssl=ss; }     \/\/ save status$/;"	f	class:simlib3::Integrator
ScalarProduct	simlib2D.cc	/^Input ScalarProduct(Input2D x, Input2D y) { return new _ScalarProduct2D(x,y); }$/;"	f	namespace:simlib3
ScalarProduct	simlib3D.cc	/^Input ScalarProduct(Input3D x, Input3D y) { return new _ScalarProduct3D(x,y); }$/;"	f	namespace:simlib3
ScheduleAt	calendar.cc	/^void CalendarList::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarList
ScheduleAt	calendar.cc	/^void CalendarQueue::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarQueue
ScheduleAt	calendar.cc	/^void SQS::ScheduleAt(Entity *e, double t) { \/\/ used by scheduling operations$/;"	f	class:simlib3::SQS
SchedulingBeforeTime	errors.h	/^\/* 19 *\/ SchedulingBeforeTime,$/;"	e	enum:_ErrEnum
SearchMethod	numint.cc	/^IntegrationMethod* IntegrationMethod::SearchMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod
SearchMinTime	calendar.cc	/^void CalendarQueue::SearchMinTime (double starttime)$/;"	f	class:simlib3::CalendarQueue
Seize	facility.cc	/^void Facility::Seize(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility
Seize	process.cc	/^void Process::Seize(Facility & f, ServicePriority_t sp \/* = 0 *\/ )$/;"	f	class:simlib3::Process
Semaphore	semaphor.cc	/^Semaphore::Semaphore()$/;"	f	class:simlib3::Semaphore
Semaphore	semaphor.cc	/^Semaphore::Semaphore(const char *name)$/;"	f	class:simlib3::Semaphore
Semaphore	simlib.h	/^class Semaphore : public SimObject {$/;"	c	namespace:simlib3
SemaphoreError	errors.h	/^\/* 67 *\/ SemaphoreError,$/;"	e	enum:_ErrEnum
ServicePriority_t	simlib.h	/^typedef unsigned char ServicePriority_t;$/;"	t	namespace:simlib3
Set	algloop.cc	/^void AlgLoop::Set(double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop
Set	calendar.cc	/^    void Set(Entity *e, double t) {$/;"	f	struct:simlib3::EventNotice
Set	delay.cc	/^double Delay::Set(double newdelay)$/;"	f	class:simlib3::Delay
Set	intg.cc	/^void Integrator::Set(double value)$/;"	f	class:simlib3::Integrator
Set	intg.cc	/^void Status::Set(double value)$/;"	f	class:simlib3::Status
Set	simlib.h	/^  Input Set(Input i)     {$/;"	f	class:simlib3::Input
Set	simlib2D.h	/^  Input2D Set(Input2D i)    { Input2D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input2D
Set	simlib3D.h	/^  Input3D Set(Input3D i)     { Input3D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input3D
Set	zdelay.h	/^    void Set(double new_dt) { dt = new_dt; }$/;"	f	class:simlib3::ZDelayTimer
SetAccuracy	intg.cc	/^void SetAccuracy(double _abserr, double _relerr)$/;"	f	namespace:simlib3
SetAccuracy	intg.cc	/^void SetAccuracy(double relerr)$/;"	f	namespace:simlib3
SetAccuracyError	errors.h	/^\/* 11 *\/ SetAccuracyError,$/;"	e	enum:_ErrEnum
SetAll	cond.cc	/^void aCondition::SetAll() {$/;"	f	class:simlib3::aCondition
SetBaseRandomGenerator	random1.cc	/^void SetBaseRandomGenerator(double (*new_gen)())$/;"	f	namespace:simlib3
SetCalendar	calendar.cc	/^void SetCalendar(const char *name) {$/;"	f	namespace:simlib3
SetCapacity	store.cc	/^void Store::SetCapacity(unsigned long newcapacity)$/;"	f	class:simlib3::Store
SetCapacityError	errors.h	/^\/* 48 *\/ SetCapacityError,$/;"	e	enum:_ErrEnum
SetDiff	simlib.h	/^  void SetDiff(double d) { dd=d; }$/;"	f	class:simlib3::Integrator
SetErrNo	simlib.h	/^  static void SetErrNo(int num) { \/\/ set # of errors$/;"	f	class:simlib3::IntegrationMethod
SetInput	simlib.h	/^  Input SetInput(Input inp) { return in.Set(inp); } \/\/ change input block$/;"	f	class:simlib3::Condition
SetInput	simlib.h	/^  Input SetInput(Input inp) { return input.Set(inp); }$/;"	f	class:simlib3::Integrator
SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator2D
SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock2D1
SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator3D
SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock3D1
SetMethod	numint.cc	/^void IntegrationMethod::SetMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod
SetMethod	simlib.h	/^inline void SetMethod(const char* name)$/;"	f	namespace:simlib3
SetMinTime	calendar.cc	/^    void SetMinTime(double t) { mintime=t; }$/;"	f	class:simlib3::Calendar
SetName	name.cc	/^void SetName(SimObject & o, const char *name)$/;"	f	namespace:simlib3
SetName	name.cc	/^void SetName(SimObject * o, const char *name)$/;"	f	namespace:simlib3
SetName	object.cc	/^void SimObject::SetName(const char *name)$/;"	f	class:simlib3::SimObject
SetNewStatus	cond.cc	/^void Condition::SetNewStatus()$/;"	f	class:simlib3::Condition
SetOldDiff	simlib.h	/^  void SetOldDiff(double d) { ddl=d; }$/;"	f	class:simlib3::Integrator
SetOldState	simlib.h	/^  void SetOldState(double s) { ssl=s; }$/;"	f	class:simlib3::Integrator
SetOldState	simlib.h	/^  void SetOldState(double s) { stl=s; }$/;"	f	class:simlib3::Status
SetOptStep	simlib.h	/^  static void SetOptStep(double opt_step) { \/\/ set optimal step size$/;"	f	class:simlib3::IntegrationMethod
SetOutput	print.cc	/^void SetOutput(const char *name)$/;"	f	namespace:simlib3
SetQueue	facility.cc	/^void Facility::SetQueue(Queue * queue)$/;"	f	class:simlib3::Facility
SetQueue	store.cc	/^void Store::SetQueue(Queue *queue)$/;"	f	class:simlib3::Store
SetQueueError	errors.h	/^\/* 49 *\/ SetQueueError,$/;"	e	enum:_ErrEnum
SetStartMode	simlib.h	/^  void SetStartMode(bool start_mode) {  \/\/ set flag on\/off$/;"	f	class:simlib3::SingleStepMethod
SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* name, const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod
SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod
SetStarter	simlib.h	/^inline void SetStarter(const char* name, const char* slave_name)$/;"	f	namespace:simlib3
SetStarter	simlib.h	/^inline void SetStarter(const char* slave_name)$/;"	f	namespace:simlib3
SetState	simlib.h	/^  void SetState(double s) { ss=s; }$/;"	f	class:simlib3::Integrator
SetState	simlib.h	/^  void SetState(double s) { st=s; }$/;"	f	class:simlib3::Status
SetStep	intg.cc	/^void SetStep(double _dtmin, double _dtmax)$/;"	f	namespace:simlib3
SetStep	sampler.cc	/^double Sampler::SetStep(double dt)$/;"	f	class:simlib3::Sampler
SetStep	simlib.h	/^inline void SetStep(double dt) { SetStep(dt,dt); }$/;"	f	namespace:simlib3
SetStepError	errors.h	/^\/* 8 *\/ SetStepError,$/;"	e	enum:_ErrEnum
SetStepError2	errors.h	/^\/* 10 *\/ SetStepError2,$/;"	e	enum:_ErrEnum
SetStepSize	simlib.h	/^  static void SetStepSize(double step_size) { \/\/ set step size$/;"	f	class:simlib3::IntegrationMethod
SetValid	simlib.h	/^  void SetValid(bool flag) { ValueOK = flag; } \/\/ set valid flag$/;"	f	class:simlib3::Status
Sign	fun.cc	/^Input Sign(Input x)             { return new Function1(x, sign); }$/;"	f	namespace:simlib3
SimObject	object.cc	/^SimObject::SimObject() :$/;"	f	class:simlib3::SimObject
SimObject	simlib.h	/^class SimObject {$/;"	c	namespace:simlib3
SimObject_allocated	object.cc	/^static bool SimObject_allocated = false;$/;"	m	namespace:simlib3	file:
Sin	fun.cc	/^Input Sin(Input x)              { return new Function1(x, sin); }$/;"	f	namespace:simlib3
SingleStepMethod	simlib.h	/^  SingleStepMethod(const char* name) :  \/\/ initialize method and registrate it$/;"	f	class:simlib3::SingleStepMethod
SingleStepMethod	simlib.h	/^class SingleStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3
Size	calendar.cc	/^    unsigned Size()  const { return _size; }$/;"	f	class:simlib3::Calendar
Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::IntegratorContainer
Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::StatusContainer
SkipBlanks	generr.c	/^void SkipBlanks(void)$/;"	f
SlaveName	simlib.h	/^  char* SlaveName;  \/\/ the name of the method used for starting$/;"	m	class:simlib3::MultiStepMethod
SlavePtr	numint.cc	/^SingleStepMethod* MultiStepMethod::SlavePtr(void)$/;"	f	class:simlib3::MultiStepMethod
Slave_Ptr	simlib.h	/^  SingleStepMethod* Slave_Ptr;  \/\/ pointer to the method used for starting$/;"	m	class:simlib3::MultiStepMethod
Sqr	continuous.cc	/^Input Sqr(Input x) { return new _Mul(x,x); }$/;"	f	namespace:simlib3
Sqrt	fun.cc	/^Input Sqrt(Input x)             { return new Function1(x, sqrt); }$/;"	f	namespace:simlib3
Start	sampler.cc	/^void Sampler::Start()$/;"	f	class:simlib3::Sampler
Start	zdelay.cc	/^void ZDelayTimer::Start() \/\/ clock activation$/;"	f	class:simlib3::ZDelayTimer
StartMode	simlib.h	/^  bool StartMode;$/;"	m	class:simlib3::SingleStepMethod
StartSampling	graph.cc	/^void Graph::StartSampling()$/;"	f	class:simlib3::Graph
StartTime	run.cc	/^const double & StartTime = SIMLIB_StartTime;    \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
StartTime	simlib.h	/^  double StartTime() const     { return t0; }$/;"	f	class:simlib3::TStat
StartTime	simlib.h	/^  double StartTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t
Stat	simlib.h	/^class Stat : public SimObject {$/;"	c	namespace:simlib3
Stat	stat.cc	/^Stat::Stat() :$/;"	f	class:simlib3::Stat
Stat	stat.cc	/^Stat::Stat(const char *name) :$/;"	f	class:simlib3::Stat
StatDT	simlib.h	/^    Stat  StatDT;                        \/\/ statistics$/;"	m	class:simlib3::Queue
StatDispError	errors.h	/^\/* 70 *\/ StatDispError,$/;"	e	enum:_ErrEnum
StatN	simlib.h	/^    TStat StatN;$/;"	m	class:simlib3::Queue
StatNoRecError	errors.h	/^\/* 69 *\/ StatNoRecError,$/;"	e	enum:_ErrEnum
StatRefError	errors.h	/^\/* 34 *\/ StatRefError,$/;"	e	enum:_ErrEnum
StateCond	numint.cc	/^bool IntegrationMethod::StateCond(void)$/;"	f	class:simlib3::IntegrationMethod
Status	intg.cc	/^Status::Status(Input i, double initvalue): aContiBlock1(i)$/;"	f	class:simlib3::Status
Status	simlib.h	/^class Status : public aContiBlock1 {   \/\/ state-variables$/;"	c	namespace:simlib3
StatusContainer	simlib.h	/^class StatusContainer {$/;"	c	namespace:simlib3
StatusIterator	simlib.h	/^  typedef StatusContainer::iterator StatusIterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::StatusMethod
StatusMList	simlib.h	/^  std::list<Memory*> StatusMList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::StatusMethod
StatusMemory	simlib.h	/^    StatusMemory(std::list<Memory*>* PtrList=PtrStatusMList) : Memory(PtrList) { }$/;"	f	class:simlib3::StatusMethod::StatusMemory
StatusMemory	simlib.h	/^  class StatusMemory : public Memory {$/;"	c	class:simlib3::StatusMethod
StatusMethod	numint.cc	/^StatusMethod::StatusMethod(const char* name):$/;"	f	class:simlib3::StatusMethod
StatusMethod	simlib.h	/^class StatusMethod : public SingleStepMethod {$/;"	c	namespace:simlib3
StatusResize	numint.cc	/^void StatusMethod::StatusResize(size_t size)$/;"	f	class:simlib3::StatusMethod
StdDev	stat.cc	/^double Stat::StdDev() const$/;"	f	class:simlib3::Stat
Step	simlib.h	/^  double Step() const    { return step; }$/;"	f	class:simlib3::Histogram
StepCount	simlib.h	/^  long   StepCount;     \/\/ for continuous simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t
StepSim	numint.cc	/^void IntegrationMethod::StepSim(void)$/;"	f	class:simlib3::IntegrationMethod
StepSize	intg.cc	/^const double &StepSize=SIMLIB_StepSize;      \/\/!< actual integration step$/;"	m	namespace:simlib3	file:
Stop	run.cc	/^void Stop()$/;"	f	namespace:simlib3
Stop	sampler.cc	/^void Sampler::Stop()$/;"	f	class:simlib3::Sampler
Stop	zdelay.cc	/^void ZDelayTimer::Stop() \/\/ clock deactivation$/;"	f	class:simlib3::ZDelayTimer
StopFlag	run.cc	/^static bool StopFlag = false;           \/\/ if set, stop simulation run$/;"	m	namespace:simlib3	file:
StopSampling	graph.cc	/^void Graph::StopSampling()$/;"	f	class:simlib3::Graph
Store	simlib.h	/^class Store : public SimObject {$/;"	c	namespace:simlib3
Store	store.cc	/^Store::Store() :$/;"	f	class:simlib3::Store
Store	store.cc	/^Store::Store(const char * name, unsigned long _capacity) :$/;"	f	class:simlib3::Store
Store	store.cc	/^Store::Store(const char *name, unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store
Store	store.cc	/^Store::Store(unsigned long _capacity) :$/;"	f	class:simlib3::Store
Store	store.cc	/^Store::Store(unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store
StoreRefError	errors.h	/^\/* 45 *\/ StoreRefError,$/;"	e	enum:_ErrEnum
StoreState	numint.cc	/^void StatusMethod::StoreState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod
Sum	simlib.h	/^  double Sum() const           { return sx; }$/;"	f	class:simlib3::Stat
Sum	simlib.h	/^  double Sum() const           { return sxt; }$/;"	f	class:simlib3::TStat
SumSquare	simlib.h	/^  double SumSquare() const     { return sx2; }$/;"	f	class:simlib3::Stat
SumSquare	simlib.h	/^  double SumSquare() const     { return sx2t; }$/;"	f	class:simlib3::TStat
Summarize	numint.cc	/^void IntegrationMethod::Summarize(void)$/;"	f	class:simlib3::IntegrationMethod
T	continuous.cc	/^aContiBlock & T = _T;   \/\/ TODO try Input$/;"	m	namespace:simlib3	file:
T0	simlib.h	/^  double T0; \/\/ initial value$/;"	m	class:simlib3::AlgLoop
TA	simlib.h	/^  double TA; \/\/ boundary values of interval$/;"	m	class:simlib3::AlgLoop
TABLE	generr.c	/^} TABLE;$/;"	t	typeref:struct:__anon1	file:
TB	simlib.h	/^  double TB; \/\/ (also used for convergency check)$/;"	m	class:simlib3::AlgLoop
TERMINATION	internal.h	/^    TERMINATION,    \/\/ after Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
THREAD_EXIT	process.cc	165;"	d	file:
THREAD_INTERRUPT	process.cc	155;"	d	file:
THREAD_INTERRUPT_f	process.cc	/^static void THREAD_INTERRUPT_f()$/;"	f	namespace:simlib3
TRUE	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	e	enum:Boolean	file:
TStat	simlib.h	/^class TStat : public SimObject {$/;"	c	namespace:simlib3
TStat	tstat.cc	/^TStat::TStat(const char *name, double initval) :$/;"	f	class:simlib3::TStat
TStat	tstat.cc	/^TStat::TStat(double initval):$/;"	f	class:simlib3::TStat
TStatNotInitialized	errors.h	/^\/* 36 *\/ TStatNotInitialized,$/;"	e	enum:_ErrEnum
TStatRefError	errors.h	/^\/* 35 *\/ TStatRefError,$/;"	e	enum:_ErrEnum
T_MEASURE	calendar.cc	/^static unsigned long long T_MEASURE;$/;"	m	namespace:__anon2	file:
Table	generr.c	/^    struct tabitem Table[MAXERR];$/;"	m	struct:__anon1	typeref:struct:__anon1::tabitem	file:
Tan	fun.cc	/^Input Tan(Input x)              { return new Function1(x, tan); }$/;"	f	namespace:simlib3
Terminate	entity.cc	/^void Entity::Terminate()$/;"	f	class:simlib3::Entity
Terminate	event.cc	/^void Event::Terminate()$/;"	f	class:simlib3::Event
Terminate	process.cc	/^void Process::Terminate()$/;"	f	class:simlib3::Process
Test	_test_.cc	/^  Test(Input F):$/;"	f	struct:Test
Test	_test_.cc	/^struct Test {$/;"	s	file:
Test	cond.cc	/^bool Condition::Test() {$/;"	f	class:simlib3::Condition
Test	simlib.h	/^  bool Test() { return Condition::Test() && Down(); }$/;"	f	class:simlib3::ConditionDown
Test	simlib.h	/^  bool Test() { return Condition::Test() && Up(); }$/;"	f	class:simlib3::ConditionUp
TestAll	cond.cc	/^void aCondition::TestAll()$/;"	f	class:simlib3::aCondition
TestAndSetFlag	internal.h	/^inline bool SimObject::TestAndSetFlag(bool new_value, unsigned n) {$/;"	f	class:simlib3::SimObject
TestProcess	_test_.cc	/^class TestProcess : public Process {$/;"	c	file:
Time	run.cc	/^const double & Time      = SIMLIB_Time;         \/\/ simulation time$/;"	m	namespace:simlib3	file:
Triag	random2.cc	/^double Triag(double mod, double min, double max)$/;"	f	namespace:simlib3
TurnOff	numint.cc	/^void IntegrationMethod::TurnOff(void)$/;"	f	class:simlib3::IntegrationMethod
TurnOff	numint.cc	/^void MultiStepMethod::TurnOff(void)$/;"	f	class:simlib3::MultiStepMethod
TurnOff	numint.cc	/^void StatusMethod::TurnOff(void)$/;"	f	class:simlib3::StatusMethod
TwiceInitError	errors.h	/^\/* 5 *\/ TwiceInitError,$/;"	e	enum:_ErrEnum
UnRegister	delay.cc	/^      static void UnRegister(Delay *p) {\/\/ must be called from Delay destructor$/;"	f	class:simlib3::SIMLIB_Delay
UnRegister	zdelay.cc	/^    static void UnRegister(ZDelayTimer *p) { \/\/ called from ZDelayTimer destructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer
UnRegister	zdelay.cc	/^void ZDelayTimer::UnRegister(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer
UnRegisterReference	simlib.h	878;"	d
Uniform	random2.cc	/^double Uniform(double l, double h)$/;"	f	namespace:simlib3
UnitVector	simlib2D.cc	/^Input2D UnitVector(Input2D x) { return new _Norm2D(x); }$/;"	f	namespace:simlib3
UnitVector	simlib3D.cc	/^Input3D UnitVector(Input3D x) { return new _Norm3D(x); }$/;"	f	namespace:simlib3
UnknownError	errors.h	/^\/* 1 *\/ UnknownError,$/;"	e	enum:_ErrEnum
Up	simlib.h	/^  bool Up()     { return ccl<cc; }      \/\/ change: FALSE->TRUE$/;"	f	class:simlib3::Condition
Used	simlib.h	/^  unsigned long Used() const { return used; }           \/\/!< used capacity$/;"	f	class:simlib3::Store
UserError	errors.h	/^\/* 88 *\/ UserError,$/;"	e	enum:_ErrEnum
V	semaphor.cc	/^void Semaphore::V()$/;"	f	class:simlib3::Semaphore
Value	algloop.cc	/^double Bisect::Value()$/;"	f	class:simlib3::Bisect
Value	algloop.cc	/^double Iterations::Value()$/;"	f	class:simlib3::Iterations
Value	algloop.cc	/^double Newton::Value()$/;"	f	class:simlib3::Newton
Value	algloop.cc	/^double RegulaFalsi::Value()$/;"	f	class:simlib3::RegulaFalsi
Value	continuous.cc	/^  virtual double Value () { return Time; }$/;"	f	class:simlib3::_Time
Value	continuous.cc	/^  virtual double Value()    { return -InputValue(); }$/;"	f	class:simlib3::_UMinus
Value	continuous.cc	/^  virtual double Value() { return Input1Value() * Input2Value(); }$/;"	f	class:simlib3::_Mul
Value	continuous.cc	/^  virtual double Value() { return Input1Value() + Input2Value(); }$/;"	f	class:simlib3::_Add
Value	continuous.cc	/^  virtual double Value() { return Input1Value() - Input2Value(); }$/;"	f	class:simlib3::_Sub
Value	continuous.cc	/^  virtual double Value() { return Input1Value() \/ Input2Value(); }$/;"	f	class:simlib3::_Div
Value	continuous.cc	/^double Expression::Value() { AlgLoopDetector _(this); return InputValue(); }$/;"	f	class:simlib3::Expression
Value	delay.cc	/^double Delay::Value()$/;"	f	class:simlib3::Delay
Value	fun.cc	/^double Function1::Value() {$/;"	f	class:simlib3::Function1
Value	fun.cc	/^double Function2::Value() {$/;"	f	class:simlib3::Function2
Value	intg.cc	/^double Integrator::Value()$/;"	f	class:simlib3::Integrator
Value	intg.cc	/^double Status::Value()$/;"	f	class:simlib3::Status
Value	optimize.h	/^    double Value() const { return value; }$/;"	f	class:simlib3::Param
Value	simlib.h	/^  double Value() const { return bp->Value(); } \/\/!< get target block value$/;"	f	class:simlib3::Input
Value	simlib.h	/^  virtual bool Value() { return cc; }   \/\/ status$/;"	f	class:simlib3::Condition
Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Parameter
Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Variable
Value	simlib.h	/^  virtual double Value ()       { return value; }$/;"	f	class:simlib3::Constant
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Add2D
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Div2D
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Mul2D1D
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Norm2D
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Sub2D
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_UMinus2D
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs2D
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct2D
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYpart
Value	simlib2D.cc	/^Value2D Integrator2D::Value()$/;"	f	class:simlib3::Integrator2D
Value	simlib2D.cc	/^double Integrator2D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator2D::special_input
Value	simlib2D.h	/^  Value2D Value()           { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input2D
Value	simlib2D.h	/^  Value2D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression2D
Value	simlib2D.h	/^  virtual Value2D Value()            { return value; }$/;"	f	class:simlib3::Variable2D
Value	simlib2D.h	/^  virtual Value2D Value()  { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant2D
Value	simlib2D.h	/^  virtual Value2D Value() {$/;"	f	class:simlib3::Adaptor2D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Add3D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Div3D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D1D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Norm3D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Sub3D
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_UMinus3D
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs3D
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct3D
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYZpart
Value	simlib3D.cc	/^Value3D Integrator3D::Value()$/;"	f	class:simlib3::Integrator3D
Value	simlib3D.cc	/^double Integrator3D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator3D::special_input
Value	simlib3D.h	/^  Value3D Value()            { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input3D
Value	simlib3D.h	/^  Value3D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression3D
Value	simlib3D.h	/^  virtual Value3D Value ()          { return value; }$/;"	f	class:simlib3::Variable3D
Value	simlib3D.h	/^  virtual Value3D Value () { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant3D
Value	simlib3D.h	/^  virtual Value3D Value() {$/;"	f	class:simlib3::Adaptor3D
Value	stdblock.cc	/^double Frict::Value()$/;"	f	class:simlib3::Frict
Value	stdblock.cc	/^double Insv::Value()$/;"	f	class:simlib3::Insv
Value	stdblock.cc	/^double Lim::Value()$/;"	f	class:simlib3::Lim
Value	stdblock.cc	/^double Qntzr::Value()$/;"	f	class:simlib3::Qntzr
Value	stdblock.cc	/^double Rline::Value()$/;"	f	class:simlib3::Rline
Value	zdelay.cc	/^double ZDelay::Value()$/;"	f	class:simlib3::ZDelay
Value2D	simlib2D.h	/^  Value2D(double x, double y) : _x(x), _y(y) {}$/;"	f	class:simlib3::Value2D
Value2D	simlib2D.h	/^class Value2D {$/;"	c	namespace:simlib3
Value3D	simlib3D.h	/^  Value3D(double x, double y, double z) : _x(x), _y(y), _z(z) {}$/;"	f	class:simlib3::Value3D
Value3D	simlib3D.h	/^class Value3D {$/;"	c	namespace:simlib3
ValueOK	simlib.h	/^  bool ValueOK;                        \/\/ valid-flag ###$/;"	m	class:simlib3::Status
Variable	simlib.h	/^  Variable(double x=0) : value(x) {}$/;"	f	class:simlib3::Variable
Variable	simlib.h	/^class Variable : public aContiBlock {$/;"	c	namespace:simlib3
Variable2D	simlib2D.h	/^  explicit Variable2D(Value2D x=Value2D(0,0)) : value(x) {}$/;"	f	class:simlib3::Variable2D
Variable2D	simlib2D.h	/^class Variable2D : public aContiBlock2D {$/;"	c	namespace:simlib3
Variable3D	simlib3D.h	/^  explicit Variable3D(Value3D x=Value3D(0,0,0)) : value(x) {}$/;"	f	class:simlib3::Variable3D
Variable3D	simlib3D.h	/^class Variable3D : public aContiBlock3D {$/;"	c	namespace:simlib3
VoidFunctionPtr	internal.h	/^typedef void (*VoidFunctionPtr)(); \/\/ ptr to void function$/;"	t	namespace:simlib3
WU_hook	waitunti.cc	/^void WaitUntilList::WU_hook() { \/\/ get ptr to next process in WUlist or 0$/;"	f	class:simlib3::WaitUntilList
WU_print	waitunti.cc	/^    void WU_print() {$/;"	f	namespace:simlib3
Wait	barrier.cc	/^bool Barrier::Wait()$/;"	f	class:simlib3::Barrier
Wait	process.cc	/^void Process::Wait(double dtime)$/;"	f	class:simlib3::Process
WaitUntil	simlib.h	462;"	d
WaitUntilList	waitunti.cc	/^    WaitUntilList() { Dprintf(("WaitUntilList::WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:
WaitUntilList	waitunti.cc	/^class WaitUntilList {$/;"	c	namespace:simlib3	file:
Weibul	random2.cc	/^double Weibul(double lambda, double alfa)$/;"	f	namespace:simlib3
WeibullError	errors.h	/^\/* 50 *\/ WeibullError,$/;"	e	enum:_ErrEnum
Where	simlib.h	/^  List *Where() { return head; }       \/\/!< where is linked$/;"	f	class:simlib3::Link
WhichPart	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	g	class:simlib3::_XYpart	file:
WhichPart	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	g	class:simlib3::_XYZpart	file:
Xpart	simlib2D.cc	/^Input Xpart(Input2D a) { return new _XYpart(a, _XYpart::x); }$/;"	f	namespace:simlib3
Xpart	simlib3D.cc	/^Input Xpart(Input3D a) { return new _XYZpart(a, _XYZpart::x); }$/;"	f	namespace:simlib3
Y1	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW
Ypart	simlib2D.cc	/^Input Ypart(Input2D a) { return new _XYpart(a, _XYpart::y); }$/;"	f	namespace:simlib3
Ypart	simlib3D.cc	/^Input Ypart(Input3D a) { return new _XYZpart(a, _XYZpart::y); }$/;"	f	namespace:simlib3
Z	ni_abm4.h	/^  Memory Z[abm_ord];  \/\/ auxiliary memories$/;"	m	class:simlib3::ABM4
ZDelay	zdelay.cc	/^ZDelay::ZDelay( Input i, double ival ) :$/;"	f	class:simlib3::ZDelay
ZDelay	zdelay.cc	/^ZDelay::ZDelay(Input i, ZDelayTimer *p, double ival) :$/;"	f	class:simlib3::ZDelay
ZDelay	zdelay.h	/^class ZDelay : public aContiBlock1 {$/;"	c	namespace:simlib3
ZDelayContainer	zdelay.cc	/^        ZDelayContainer(): c() {}$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
ZDelayContainer	zdelay.cc	/^class ZDelayTimer::ZDelayContainer { \/\/ implementation-defined container$/;"	c	class:simlib3::ZDelayTimer	file:
ZDelayTimer	zdelay.cc	/^ZDelayTimer::ZDelayTimer(double step, bool is_default) :$/;"	f	class:simlib3::ZDelayTimer
ZDelayTimer	zdelay.h	/^class ZDelayTimer : public Event {$/;"	c	namespace:simlib3
Zpart	simlib3D.cc	/^Input Zpart(Input3D a) { return new _XYZpart(a, _XYZpart::z); }$/;"	f	namespace:simlib3
_ABORT_TXT	error.cc	33;"	d	file:
_ALLOCATED_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
_Abs2D	simlib2D.cc	/^  _Abs2D(Input2D a): in(a) {}$/;"	f	class:simlib3::_Abs2D
_Abs2D	simlib2D.cc	/^class _Abs2D: public aContiBlock {$/;"	c	namespace:simlib3	file:
_Abs3D	simlib3D.cc	/^  _Abs3D(Input3D a): in(a) {}$/;"	f	class:simlib3::_Abs3D
_Abs3D	simlib3D.cc	/^class _Abs3D: public aContiBlock {$/;"	c	namespace:simlib3	file:
_Add	continuous.cc	/^  _Add(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Add
_Add	continuous.cc	/^class _Add : public aContiBlock2 {$/;"	c	namespace:simlib3	file:
_Add2D	simlib2D.cc	/^  _Add2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Add2D
_Add2D	simlib2D.cc	/^class _Add2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:
_Add3D	simlib3D.cc	/^  _Add3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Add3D
_Add3D	simlib3D.cc	/^class _Add3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:
_Div	continuous.cc	/^  _Div(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Div
_Div	continuous.cc	/^class _Div : public aContiBlock2 {$/;"	c	namespace:simlib3	file:
_Div2D	simlib2D.cc	/^  _Div2D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Div2D
_Div2D	simlib2D.cc	/^class _Div2D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:
_Div3D	simlib3D.cc	/^  _Div3D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Div3D
_Div3D	simlib3D.cc	/^class _Div3D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:
_ERR_TXT	error.cc	31;"	d	file:
_EVAL_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
_ErrEnum	errors.h	/^enum _ErrEnum {$/;"	g
_ErrMsg	errors.cc	/^char *_ErrMsg(enum _ErrEnum N)$/;"	f	namespace:simlib3
_Errors	errors.cc	/^static char _Errors[] = {$/;"	m	namespace:simlib3	file:
_Errors	generr.c	/^static char _Errors[] = {$/;"	v	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus	file:
_Eval	continuous.cc	/^void aContiBlock::_Eval()$/;"	f	class:simlib3::aContiBlock
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul2D1D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus2D	file:
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYpart	file:
_Eval	simlib2D.cc	/^void aContiBlock2D::_Eval()$/;"	f	class:simlib3::aContiBlock2D
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D1D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus3D	file:
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYZpart	file:
_Eval	simlib3D.cc	/^void aContiBlock3D::_Eval()$/;"	f	class:simlib3::aContiBlock3D
_Eval	stdblock.cc	/^void Frict::_Eval()$/;"	f	class:simlib3::Frict
_Eval	stdblock.cc	/^void Insv::_Eval()$/;"	f	class:simlib3::Insv
_Eval	stdblock.cc	/^void Lim::_Eval()$/;"	f	class:simlib3::Lim
_Eval	stdblock.cc	/^void Qntzr::_Eval()$/;"	f	class:simlib3::Qntzr
_Eval	stdblock.cc	/^void Rline::_Eval()$/;"	f	class:simlib3::Rline
_FileWrap	print.cc	/^class _FileWrap {$/;"	c	namespace:simlib3	file:
_Flags	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	g	class:simlib3::SimObject
_GET_STACK_PTR	process.cc	100;"	d	file:
_GET_STACK_PTR	process.cc	106;"	d	file:
_GET_STACK_PTR	process.cc	77;"	d	file:
_GET_STACK_PTR	process.cc	81;"	d	file:
_GET_STACK_PTR	process.cc	83;"	d	file:
_GET_STACK_PTR	process.cc	95;"	d	file:
_GraphInit	graph.cc	/^void _GraphInit()$/;"	f	namespace:simlib3
_INTERRUPTED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_INT_ERR_TXT	error.cc	32;"	d	file:
_Ident	simlib.h	/^    unsigned long _Ident;           \/\/!< unique identification number of entity$/;"	m	class:simlib3::Entity
_MarkTime	simlib.h	/^    double _MarkTime;               \/\/ beginning of waiting in queue ###!!!$/;"	m	class:simlib3::Entity
_Mul	continuous.cc	/^  _Mul(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Mul
_Mul	continuous.cc	/^class _Mul : public aContiBlock2 {$/;"	c	namespace:simlib3	file:
_Mul2D1D	simlib2D.cc	/^  _Mul2D1D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Mul2D1D
_Mul2D1D	simlib2D.cc	/^class _Mul2D1D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:
_Mul3D	simlib3D.cc	/^  _Mul3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Mul3D
_Mul3D	simlib3D.cc	/^class _Mul3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:
_Mul3D1D	simlib3D.cc	/^  _Mul3D1D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Mul3D1D
_Mul3D1D	simlib3D.cc	/^class _Mul3D1D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:
_Norm2D	simlib2D.cc	/^  _Norm2D(Input2D a): aContiBlock2D1(a) {}$/;"	f	class:simlib3::_Norm2D
_Norm2D	simlib2D.cc	/^class _Norm2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:
_Norm3D	simlib3D.cc	/^  _Norm3D(Input3D a): aContiBlock3D1(a) {}$/;"	f	class:simlib3::_Norm3D
_Norm3D	simlib3D.cc	/^class _Norm3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:
_Number	entity.cc	/^unsigned long Entity::_Number = 0L;     \/\/ # of entity creations$/;"	m	class:simlib3::Entity	file:
_Number	simlib.h	/^    static unsigned long _Number;   \/\/!< current number of entities$/;"	m	class:simlib3::Entity
_OWNQ	store.cc	31;"	d	file:
_OWNQ1	facility.cc	30;"	d	file:
_PREPARED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_Print	print.cc	/^int _Print(const char *fmt, ...)$/;"	f	namespace:simlib3
_ProcessDispatcherStatusBuffer	process.cc	/^static jmp_buf _ProcessDispatcherStatusBuffer;  \/\/ stack state before dispatch$/;"	m	namespace:simlib3	file:
_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Facility
_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Store
_RUNNING	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_RemainingTime	simlib.h	/^        double _RemainingTime; \/\/ rest of time of interrupted service (Facility) ###$/;"	m	union:simlib3::Entity::__anon5
_RequiredCapacity	simlib.h	/^        unsigned long _RequiredCapacity; \/\/ required store capacity of Store$/;"	m	union:simlib3::Entity::__anon5
_Run	event.cc	/^void Event::_Run() throw()$/;"	f	class:simlib3::Event
_Run	process.cc	/^void Process::_Run() throw() \/\/ no exceptions$/;"	f	class:simlib3::Process
_SET_STACK_PTR	process.cc	101;"	d	file:
_SET_STACK_PTR	process.cc	107;"	d	file:
_SET_STACK_PTR	process.cc	78;"	d	file:
_SET_STACK_PTR	process.cc	85;"	d	file:
_SET_STACK_PTR	process.cc	96;"	d	file:
_SPrio	simlib.h	/^    ServicePriority_t _SPrio;           \/\/!< priority of service in Facility$/;"	m	class:simlib3::Entity
_ScalarProduct2D	simlib2D.cc	/^  _ScalarProduct2D(Input2D a, Input2D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct2D
_ScalarProduct2D	simlib2D.cc	/^class _ScalarProduct2D: public aContiBlock {$/;"	c	namespace:simlib3	file:
_ScalarProduct3D	simlib3D.cc	/^  _ScalarProduct3D(Input3D a, Input3D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct3D
_ScalarProduct3D	simlib3D.cc	/^class _ScalarProduct3D: public aContiBlock {$/;"	c	namespace:simlib3	file:
_SetTime	internal.h	209;"	d
_StackBase	process.cc	/^static char *volatile _StackBase = 0;    \/\/ start of stack data area$/;"	m	namespace:simlib3	file:
_StackBase2	process.cc	/^static char *volatile _StackBase2 = 0;   \/\/ CHECKING start of stack data area$/;"	m	namespace:simlib3	file:
_StackSize	process.cc	/^static volatile size_t _StackSize = 0;   \/\/ temporary - global stack size$/;"	m	namespace:simlib3	file:
_Sub	continuous.cc	/^  _Sub(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Sub
_Sub	continuous.cc	/^class _Sub : public aContiBlock2 {$/;"	c	namespace:simlib3	file:
_Sub2D	simlib2D.cc	/^  _Sub2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Sub2D
_Sub2D	simlib2D.cc	/^class _Sub2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:
_Sub3D	simlib3D.cc	/^  _Sub3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Sub3D
_Sub3D	simlib3D.cc	/^class _Sub3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:
_T	continuous.cc	/^static class _Time _T;$/;"	m	namespace:simlib3	typeref:class:simlib3::_Time	file:
_TERMINATED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_Time	continuous.cc	/^  _Time() {}$/;"	f	class:simlib3::_Time
_Time	continuous.cc	/^class _Time: public aContiBlock {$/;"	c	namespace:simlib3	file:
_UMinus	continuous.cc	/^  _UMinus(Input a): aContiBlock1(a) {$/;"	f	class:simlib3::_UMinus
_UMinus	continuous.cc	/^class _UMinus: public aContiBlock1 {$/;"	c	namespace:simlib3	file:
_UMinus2D	simlib2D.cc	/^  _UMinus2D(Input2D a): aContiBlock2D1(a) {$/;"	f	class:simlib3::_UMinus2D
_UMinus2D	simlib2D.cc	/^class _UMinus2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:
_UMinus3D	simlib3D.cc	/^  _UMinus3D(Input3D a): aContiBlock3D1(a) {$/;"	f	class:simlib3::_UMinus3D
_UMinus3D	simlib3D.cc	/^class _UMinus3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:
_WARNING_TXT	error.cc	34;"	d	file:
_WaitUntil	waitunti.cc	/^bool Process::_WaitUntil(bool test)$/;"	f	class:simlib3::Process
_WaitUntilRemove	waitunti.cc	/^void Process::_WaitUntilRemove() {$/;"	f	class:simlib3::Process
_XYZpart	simlib3D.cc	/^  _XYZpart(Input3D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYZpart
_XYZpart	simlib3D.cc	/^class _XYZpart: public aContiBlock {$/;"	c	namespace:simlib3	file:
_XYpart	simlib2D.cc	/^  _XYpart(Input2D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYpart
_XYpart	simlib2D.cc	/^class _XYpart: public aContiBlock {$/;"	c	namespace:simlib3	file:
__SIMLIB2D_H	simlib2D.h	17;"	d
__SIMLIB3D_H	simlib3D.h	17;"	d
__SIMLIB_OPTIMIZE_H	optimize.h	13;"	d
__SIMLIB__	simlib.h	8;"	d
__SIMLIB__INTERNAL_H__	internal.h	35;"	d
_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div2D	file:
_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul2D1D	file:
_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div3D	file:
_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul3D1D	file:
_context	simlib.h	/^  void * _context;                      \/\/!< process context pointer$/;"	m	class:simlib3::Process
_evn	simlib.h	/^    EventNotice *_evn;                  \/\/!< points to calendar item, iff scheduled$/;"	m	class:simlib3::Entity
_flags	simlib.h	/^  unsigned     _flags;$/;"	m	class:simlib3::SimObject
_gam	random2.cc	/^static double _gam(double AK)$/;"	f	namespace:simlib3
_instance	calendar.cc	/^    static Calendar * _instance;        \/\/!< pointer to single instance$/;"	m	class:simlib3::Calendar	file:
_instance	calendar.cc	/^Calendar * Calendar::_instance = 0;$/;"	m	class:simlib3::Calendar	file:
_name	simlib.h	/^  const char * _name;$/;"	m	class:simlib3::SimObject
_size	calendar.cc	/^    unsigned _size;     \/\/!< number of scheduled items$/;"	m	class:simlib3::Calendar	file:
_status	simlib.h	/^  } _status;$/;"	m	class:simlib3::Process	typeref:enum:simlib3::Process::ProcessStatus_t
_wait_until	simlib.h	/^  bool _wait_until;                     \/\/ waiting for condition$/;"	m	class:simlib3::Process
_x	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D
_x	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D
_x	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D
_x	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D
_y	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D
_y	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D
_y	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D
_y	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D
_z	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D
_z	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D
a	simlib2D.h	/^    Value2D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator2D::special_input
a	simlib3D.h	/^    Value3D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator3D::special_input
aBlock	simlib.h	/^class aBlock : public SimObject {                \/\/ base class$/;"	c	namespace:simlib3
aCondition	cond.cc	/^aCondition::aCondition() :$/;"	f	class:simlib3::aCondition
aCondition	simlib.h	/^class aCondition : public aBlock {$/;"	c	namespace:simlib3
aContiBlock	simlib.h	/^    aContiBlock(): isEvaluated(false) {}$/;"	f	class:simlib3::aContiBlock
aContiBlock	simlib.h	/^class aContiBlock : public aBlock {$/;"	c	namespace:simlib3
aContiBlock1	continuous.cc	/^aContiBlock1::aContiBlock1(Input i) : input(i)$/;"	f	class:simlib3::aContiBlock1
aContiBlock1	simlib.h	/^class aContiBlock1 : public aContiBlock {$/;"	c	namespace:simlib3
aContiBlock2	continuous.cc	/^aContiBlock2::aContiBlock2(Input i1, Input i2) : input1(i1), input2(i2)$/;"	f	class:simlib3::aContiBlock2
aContiBlock2	simlib.h	/^class aContiBlock2 : public aContiBlock {$/;"	c	namespace:simlib3
aContiBlock2D	simlib2D.cc	/^aContiBlock2D::aContiBlock2D():$/;"	f	class:simlib3::aContiBlock2D
aContiBlock2D	simlib2D.h	/^class aContiBlock2D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3
aContiBlock2D1	simlib2D.cc	/^aContiBlock2D1::aContiBlock2D1(Input2D i) : input(i)$/;"	f	class:simlib3::aContiBlock2D1
aContiBlock2D1	simlib2D.h	/^class aContiBlock2D1 : public aContiBlock2D {$/;"	c	namespace:simlib3
aContiBlock2D2	simlib2D.cc	/^aContiBlock2D2::aContiBlock2D2(Input2D i1, Input2D i2)$/;"	f	class:simlib3::aContiBlock2D2
aContiBlock2D2	simlib2D.h	/^class aContiBlock2D2 : public aContiBlock2D {$/;"	c	namespace:simlib3
aContiBlock2D3	simlib2D.cc	/^aContiBlock2D3::aContiBlock2D3(Input2D i1, Input2D i2, Input2D i3)$/;"	f	class:simlib3::aContiBlock2D3
aContiBlock2D3	simlib2D.h	/^class aContiBlock2D3 : public aContiBlock2D2 {$/;"	c	namespace:simlib3
aContiBlock3	continuous.cc	/^aContiBlock3::aContiBlock3(Input i1, Input i2, Input i3)$/;"	f	class:simlib3::aContiBlock3
aContiBlock3	simlib.h	/^class aContiBlock3 : public aContiBlock {$/;"	c	namespace:simlib3
aContiBlock3D	simlib3D.cc	/^aContiBlock3D::aContiBlock3D():$/;"	f	class:simlib3::aContiBlock3D
aContiBlock3D	simlib3D.h	/^class aContiBlock3D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3
aContiBlock3D1	simlib3D.cc	/^aContiBlock3D1::aContiBlock3D1(Input3D i) : input(i)$/;"	f	class:simlib3::aContiBlock3D1
aContiBlock3D1	simlib3D.h	/^class aContiBlock3D1 : public aContiBlock3D {$/;"	c	namespace:simlib3
aContiBlock3D2	simlib3D.cc	/^aContiBlock3D2::aContiBlock3D2(Input3D i1, Input3D i2)$/;"	f	class:simlib3::aContiBlock3D2
aContiBlock3D2	simlib3D.h	/^class aContiBlock3D2 : public aContiBlock3D {$/;"	c	namespace:simlib3
aContiBlock3D3	simlib3D.cc	/^aContiBlock3D3::aContiBlock3D3(Input3D i1, Input3D i2, Input3D i3)$/;"	f	class:simlib3::aContiBlock3D3
aContiBlock3D3	simlib3D.h	/^class aContiBlock3D3 : public aContiBlock3D2 {$/;"	c	namespace:simlib3
aStat	simlib.h	/^class aStat : public SimObject {$/;"	c	namespace:simlib3
abm_ord	ni_abm4.h	/^const int abm_ord=4;$/;"	m	namespace:simlib3
abs	simlib2D.cc	/^double abs(const Value2D &a)$/;"	f	namespace:simlib3
abs	simlib3D.cc	/^double abs(const Value3D &a)$/;"	f	namespace:simlib3
accept_bad	opt-simann.cc	/^bool accept_bad(double eps)$/;"	f	namespace:simlib3
alloc	calendar.cc	/^    EventNotice *alloc(Entity *p, double t) {$/;"	f	class:simlib3::EventNoticeAllocator
allocator	calendar.cc	/^} allocator;  \/\/ global allocator TODO: improve -> singleton$/;"	m	namespace:simlib3	typeref:class:simlib3::EventNoticeAllocator	file:
arr	simlib.h	/^      double *arr;  \/\/ array$/;"	m	class:simlib3::IntegrationMethod::Memory
atexit_array	atexit.cc	/^static SIMLIB_atexit_function_t atexit_array[MAX_ATEXIT] = { 0, };$/;"	m	namespace:simlib3	file:
back	simlib.h	/^    Entity *back()     { return (Entity*)List::back(); }$/;"	f	class:simlib3::Queue
back	simlib.h	/^    Link *back()      { return empty() ? 0 : Link::pred; }$/;"	f	class:simlib3::List
begin	calendar.cc	/^    iterator begin()    { return l.succ; }$/;"	f	class:simlib3::CalendarListImplementation
begin	simlib.h	/^    iterator begin()   { return List::begin(); }$/;"	f	class:simlib3::Queue
begin	simlib.h	/^    iterator begin()  { return Link::succ; }$/;"	f	class:simlib3::List
begin	waitunti.cc	/^    static iterator begin() { return instance->l.begin(); }$/;"	f	class:simlib3::WaitUntilList
begin	zdelay.cc	/^        iterator begin()        { return c.begin(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
block	internal.h	/^    aContiBlock *block;$/;"	m	class:simlib3::AlgLoopDetector
bp	simlib.h	/^  aContiBlock *bp;$/;"	m	class:simlib3::Input
bp	simlib2D.h	/^  aContiBlock2D *bp;$/;"	m	class:simlib3::Input2D
bp	simlib3D.h	/^  aContiBlock3D *bp;$/;"	m	class:simlib3::Input3D
bucket_width	calendar.cc	/^    double bucket_width;    \/\/ parameter: width of each bucket$/;"	m	class:simlib3::CalendarQueue	file:
buckets	calendar.cc	/^    BucketList *buckets;    \/\/ bucket array$/;"	m	class:simlib3::CalendarQueue	file:
buckettop	calendar.cc	/^    double buckettop;       \/\/ top time of current bucket$/;"	m	class:simlib3::CalendarQueue	file:
buf	delay.cc	/^    std::deque<Pair> buf;       \/\/ use deque -- should be good enough$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:
buffer	delay.h	/^    Buffer *buffer;             \/\/ memory for past values$/;"	m	class:simlib3::Delay
c	zdelay.cc	/^        container_t c;$/;"	m	class:simlib3::ZDelayTimer::ZDelayContainer	file:
c	zdelay.h	/^    ZDelayContainer *c;$/;"	m	class:simlib3::ZDelayTimer
cal_cost_flag	calendar.cc	/^int      cal_cost_flag;$/;"	m	namespace:simlib3	file:
cal_cost_op	calendar.cc	/^const char * cal_cost_op;$/;"	m	namespace:simlib3	file:
cal_cost_size	calendar.cc	/^unsigned cal_cost_size;$/;"	m	namespace:simlib3	file:
cal_cost_time	calendar.cc	/^double   cal_cost_time;$/;"	m	namespace:simlib3	file:
capacity	simlib.h	/^  unsigned long capacity;        \/\/ capacity of store$/;"	m	class:simlib3::Store
cc	simlib.h	/^  unsigned char cc;                    \/\/ state$/;"	m	class:simlib3::Condition
ccl	simlib.h	/^  unsigned char ccl;                   \/\/ old state$/;"	m	class:simlib3::Condition
clear	calendar.cc	/^    void clear() {$/;"	f	class:simlib3::EventNoticeAllocator
clear	calendar.cc	/^    void clear(bool destroy) {$/;"	f	class:simlib3::CalendarListImplementation
clear	calendar.cc	/^void CalendarList::clear(bool destroy)$/;"	f	class:simlib3::CalendarList
clear	calendar.cc	/^void CalendarQueue::clear(bool destroy)$/;"	f	class:simlib3::CalendarQueue
clear	delay.cc	/^    virtual void clear() {$/;"	f	class:simlib3::SIMLIB_DelayBuffer
clear	list.cc	/^void List::clear()$/;"	f	class:simlib3::List
clear	queue.cc	/^void Queue::clear()$/;"	f	class:simlib3::Queue
clear	waitunti.cc	/^void WaitUntilList::clear()$/;"	f	class:simlib3::WaitUntilList
clear	zdelay.cc	/^        void clear()            { c.clear(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
clock	zdelay.h	/^    ZDelayTimer *clock;                 \/\/ timer-event for this block$/;"	m	class:simlib3::ZDelay
container	zdelay.cc	/^    static container_t *container;      \/\/ list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:
container	zdelay.cc	/^SIMLIB_ZDelayTimer::container_t * SIMLIB_ZDelayTimer::container = 0;$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:
container_t	waitunti.cc	/^    typedef std::list<Process *> container_t;$/;"	t	class:simlib3::WaitUntilList	file:
container_t	zdelay.cc	/^        typedef std::set<ZDelay*> container_t;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:
container_t	zdelay.cc	/^    typedef std::list<ZDelayTimer *> container_t; \/\/ type of container we use$/;"	t	class:simlib3::SIMLIB_ZDelayTimer	file:
count	simlib.h	/^  unsigned count;            \/\/ number of intervals$/;"	m	class:simlib3::Histogram
count	simlib2D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator2D::special_input
count	simlib3D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator3D::special_input
counter	atexit.cc	/^static int counter = 0; \/\/ internal module counter$/;"	m	namespace:simlib3	file:
create	calendar.cc	/^    static CalendarList * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarList
create	calendar.cc	/^    static CalendarQueue * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarQueue
create	waitunti.cc	/^    static void create() {  \/\/ create single instance$/;"	f	class:simlib3::WaitUntilList
create_reverse_link	calendar.cc	/^    void create_reverse_link() {$/;"	f	struct:simlib3::EventNotice
current	waitunti.cc	/^    static iterator current;$/;"	m	class:simlib3::WaitUntilList	file:
current	waitunti.cc	/^WaitUntilList::iterator WaitUntilList::current; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
dbgprnt	algloop.cc	23;"	d	file:
dbgprnt	algloop.cc	25;"	d	file:
dd	simlib.h	/^  double dd;                           \/\/ input value: y'=f(t,y)$/;"	m	class:simlib3::Integrator
ddl	simlib.h	/^  double ddl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator
debug	opt-hooke.cc	16;"	d	file:
debug	opt-simann.cc	17;"	d	file:
debug_print	calendar.cc	/^int SQS::debug_print() {                 \/\/ for debugging only$/;"	f	class:simlib3::SQS
debug_print	calendar.cc	/^void CalendarList::debug_print() \/\/ print of calendar contents$/;"	f	class:simlib3::CalendarList
debug_print	calendar.cc	/^void CalendarListImplementation::debug_print() \/\/ print of list contents$/;"	f	class:simlib3::CalendarListImplementation
debug_print	calendar.cc	/^void CalendarQueue::debug_print() \/\/ print of calendar queue contents$/;"	f	class:simlib3::CalendarQueue
default_clock	zdelay.cc	/^ZDelayTimer * ZDelay::default_clock = 0;$/;"	m	class:simlib3::ZDelay	file:
default_clock	zdelay.h	/^    static ZDelayTimer * default_clock;$/;"	m	class:simlib3::ZDelay
delete_instance	calendar.cc	/^void Calendar::delete_instance() {$/;"	f	class:simlib3::Calendar
delete_reverse_link	calendar.cc	/^    void delete_reverse_link() {$/;"	f	struct:simlib3::EventNotice
destroy	waitunti.cc	/^    static void destroy() {  \/\/ destroy single instance$/;"	f	class:simlib3::WaitUntilList
di	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER
di	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE
dptr	simlib.h	/^  unsigned *dptr;            \/\/ value array$/;"	m	class:simlib3::Histogram
dt	delay.h	/^    double dt;                  \/\/ delay time (should be > MaxStep)???###$/;"	m	class:simlib3::Delay
dt	zdelay.h	/^    double dt;          \/\/ clock period$/;"	m	class:simlib3::ZDelayTimer
empty	calendar.cc	/^    bool empty()        { return begin() == end(); }$/;"	f	class:simlib3::CalendarListImplementation
empty	simlib.h	/^    bool empty()      { return Link::succ == this; }$/;"	f	class:simlib3::List
empty	waitunti.cc	/^    static bool empty() { return instance->l.empty(); }$/;"	f	class:simlib3::WaitUntilList
end	calendar.cc	/^    iterator end()      { return &l; }$/;"	f	class:simlib3::CalendarListImplementation
end	simlib.h	/^    iterator end()     { return List::end(); }$/;"	f	class:simlib3::Queue
end	simlib.h	/^    iterator end()    { return this; }$/;"	f	class:simlib3::List
end	waitunti.cc	/^    static iterator end() { return instance->l.end(); }$/;"	f	class:simlib3::WaitUntilList
end	zdelay.cc	/^        iterator end()          { return c.end(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
entity	calendar.cc	/^    Entity * entity;$/;"	m	struct:simlib3::EventNotice	file:
enumname	generr.c	/^char enumname[MAXIDLEN + 1];$/;"	v
eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::Newton
eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::RegulaFalsi
erase	zdelay.cc	/^        void erase(ZDelay * p)  { c.erase(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
error	generr.c	/^void error(enum ErrEnum N)$/;"	f
estimate_bucket_width	calendar.cc	/^double CalendarQueue::estimate_bucket_width() {$/;"	f	class:simlib3::CalendarQueue
extract_first	calendar.cc	/^    EventNotice *extract_first() {$/;"	f	class:simlib3::CalendarListImplementation
f	simlib.h	/^  double (*f)(double); \/\/ pointer to function$/;"	m	class:simlib3::Function1
f	simlib.h	/^  double (*f)(double,double); \/\/ pointer to function$/;"	m	class:simlib3::Function2
first	calendar.cc	/^    EventNotice *first() { return *begin(); }$/;"	f	class:simlib3::CalendarListImplementation
first_time	calendar.cc	/^    double first_time() { return (*begin())->time; }$/;"	f	class:simlib3::CalendarListImplementation
flag	waitunti.cc	/^static bool flag = false; \/\/ valid iterator in WUList$/;"	m	namespace:simlib3	file:
fname	generr.c	/^char fname[512];                \/* module file name *\/$/;"	v
free	calendar.cc	/^    void free(EventNotice *en) {$/;"	f	class:simlib3::EventNoticeAllocator
freed	calendar.cc	/^    unsigned freed;$/;"	m	class:simlib3::EventNoticeAllocator	file:
front	simlib.h	/^    Entity *front()    { return (Entity*)List::front(); }$/;"	f	class:simlib3::Queue
front	simlib.h	/^    Link *front()     { return empty() ? 0 : Link::succ; }$/;"	f	class:simlib3::List
funcname	generr.c	/^char funcname[MAXIDLEN + 1];$/;"	v
function	simlib.h	/^    void (*function)(); \/\/!< function to call periodically$/;"	m	class:simlib3::Sampler
get	delay.cc	/^    virtual double get(double time) \/\/ get delayed value (with interpolation)$/;"	f	class:simlib3::SIMLIB_DelayBuffer
get	print.cc	/^    static FILE *get() {$/;"	f	class:simlib3::_FileWrap	file:
globalprocess	_test_.cc	/^TestProcess globalprocess;$/;"	v
head	simlib.h	/^  List *head;                          \/\/!< pointer to List (if any)$/;"	m	class:simlib3::Link
headfname	generr.c	/^char headfname[80];             \/* header file name *\/$/;"	v
help	generr.c	/^char help[] =$/;"	v
hi_bucket_mark	calendar.cc	/^    unsigned hi_bucket_mark;        \/\/ high bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim
hooke_step	opt-hooke.cc	/^static double hooke_step(double *delta, opt_function_t f, ParameterVector & p,$/;"	f	namespace:simlib3
in	simlib.h	/^  Entity *in;                \/\/!< entity currently in service$/;"	m	class:simlib3::Facility
in	simlib.h	/^  Input in;                            \/\/ block input$/;"	m	class:simlib3::Condition
in	simlib2D.cc	/^  Input2D in;$/;"	m	class:simlib3::_Abs2D	file:
in	simlib2D.h	/^    Input2D in;                 \/\/ 2D input$/;"	m	class:simlib3::Integrator2D::special_input
in	simlib2D.h	/^  } in;$/;"	m	class:simlib3::Integrator2D	typeref:class:simlib3::Integrator2D::special_input
in	simlib3D.cc	/^  Input3D in;$/;"	m	class:simlib3::_Abs3D	file:
in	simlib3D.h	/^    Input3D in;                 \/\/ 3D input$/;"	m	class:simlib3::Integrator3D::special_input
in	simlib3D.h	/^  } in;$/;"	m	class:simlib3::Integrator3D	typeref:class:simlib3::Integrator3D::special_input
inf	generr.c	/^FILE *inf;$/;"	v
initval	delay.h	/^    double initval;             \/\/ initial value$/;"	m	class:simlib3::Delay
initval	simlib.h	/^  double initval;                      \/\/!< initial value$/;"	m	class:simlib3::Status
initval	simlib.h	/^  double initval;                      \/\/!< initial value: y(t0)$/;"	m	class:simlib3::Integrator
initval	zdelay.h	/^    double initval;     \/\/ initial output value$/;"	m	class:simlib3::ZDelay
input	simlib.h	/^  Input input;                         \/\/!< input expression: f(t,y)$/;"	m	class:simlib3::Integrator
input	simlib.h	/^  Input input;$/;"	m	class:simlib3::aContiBlock1
input	simlib2D.cc	/^  Input2D input;$/;"	m	class:simlib3::_XYpart	file:
input	simlib2D.h	/^  Input2D input;$/;"	m	class:simlib3::aContiBlock2D1
input	simlib3D.cc	/^  Input3D input;$/;"	m	class:simlib3::_XYZpart	file:
input	simlib3D.h	/^  Input3D input;$/;"	m	class:simlib3::aContiBlock3D1
input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock2
input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock3
input1	simlib2D.cc	/^  Input2D input1;$/;"	m	class:simlib3::_ScalarProduct2D	file:
input1	simlib2D.h	/^  Input2D input1;$/;"	m	class:simlib3::aContiBlock2D2
input1	simlib3D.cc	/^  Input3D input1;$/;"	m	class:simlib3::_ScalarProduct3D	file:
input1	simlib3D.h	/^  Input3D input1;$/;"	m	class:simlib3::aContiBlock3D2
input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock2
input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock3
input2	simlib2D.cc	/^  Input2D input2;$/;"	m	class:simlib3::_ScalarProduct2D	file:
input2	simlib2D.h	/^  Input2D input2;$/;"	m	class:simlib3::aContiBlock2D2
input2	simlib3D.cc	/^  Input3D input2;$/;"	m	class:simlib3::_ScalarProduct3D	file:
input2	simlib3D.h	/^  Input3D input2;$/;"	m	class:simlib3::aContiBlock3D2
input3	simlib.h	/^  Input input3;$/;"	m	class:simlib3::aContiBlock3
input3	simlib2D.h	/^  Input2D input3;$/;"	m	class:simlib3::aContiBlock2D3
input3	simlib3D.h	/^  Input3D input3;$/;"	m	class:simlib3::aContiBlock3D3
input_value	zdelay.h	/^    double input_value;                 \/\/ temporary$/;"	m	class:simlib3::ZDelay
insert	calendar.cc	/^    void insert(Entity *e, double t) {$/;"	f	class:simlib3::CalendarListImplementation
insert	calendar.cc	/^    void insert(EventNoticeLinkBase * p) {$/;"	f	struct:simlib3::EventNoticeLinkBase
insert	zdelay.cc	/^        void insert(ZDelay * p) { c.insert(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer
insert_extracted	calendar.cc	/^    void insert_extracted(EventNotice *evn) {$/;"	f	class:simlib3::CalendarListImplementation
instance	calendar.cc	/^inline Calendar * Calendar::instance() {$/;"	f	class:simlib3::Calendar
instance	waitunti.cc	/^    static WaitUntilList *instance;   \/\/ unique list$/;"	m	class:simlib3::WaitUntilList	file:
instance	waitunti.cc	/^WaitUntilList *WaitUntilList::instance = 0; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
isAllocated	simlib.h	/^  bool isAllocated() const { return (_flags >> _ALLOCATED_FLAG)&1; }$/;"	f	class:simlib3::SimObject
isAny	cond.cc	/^bool aCondition::isAny()  { return First!=0; }$/;"	f	class:simlib3::aCondition
isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::IntegratorContainer
isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::StatusContainer
isCurrent	simlib.h	/^  bool isCurrent()     { return (_status==_RUNNING);     } \/\/ Behavior() runs$/;"	f	class:simlib3::Process
isEvaluated	simlib.h	/^    bool isEvaluated;                   \/\/TODO:remove this flag for algebraic loop detection$/;"	m	class:simlib3::aContiBlock
isEvaluated	simlib2D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock2D
isEvaluated	simlib3D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock3D
isInQueue	simlib.h	/^  virtual bool isInQueue() { return Where()!=NULL; } \/\/!< present in queue$/;"	f	class:simlib3::Link
isInterrupted	simlib.h	/^  bool isInterrupted() { return (_status==_INTERRUPTED); } \/\/ can continue$/;"	f	class:simlib3::Process
isPrepared	simlib.h	/^  bool isPrepared()    { return (_status==_PREPARED);    } \/\/ before start$/;"	f	class:simlib3::Process
isTerminated	simlib.h	/^  bool isTerminated()  { return (_status==_TERMINATED);  } \/\/ zombie$/;"	f	class:simlib3::Process
it_list	simlib.h	/^      std::list<Memory*>::iterator it_list;  \/\/ position in list$/;"	m	class:simlib3::IntegrationMethod::Memory
it_list	simlib.h	/^  IntegratorContainer::iterator it_list; \/\/!< position in list of integrators$/;"	m	class:simlib3::Integrator
it_list	simlib.h	/^  StatusContainer::iterator it_list;   \/\/!< position in list of status variables$/;"	m	class:simlib3::Status
iterator	calendar.cc	/^      iterator(EventNoticeLinkBase *pos) : p(pos) {}$/;"	f	class:simlib3::CalendarListImplementation::iterator
iterator	calendar.cc	/^    class iterator { \/\/!< bidirectional iterator$/;"	c	class:simlib3::CalendarListImplementation	file:
iterator	simlib.h	/^            iterator(Link *pos) : p(pos) {}$/;"	f	class:simlib3::List::iterator
iterator	simlib.h	/^            iterator(const iterator&x): p(x.p) {}$/;"	f	class:simlib3::List::iterator
iterator	simlib.h	/^    class iterator {$/;"	c	class:simlib3::List
iterator	simlib.h	/^    typedef List::iterator iterator;$/;"	t	class:simlib3::Queue
iterator	simlib.h	/^  typedef std::list<Integrator*>::iterator iterator;$/;"	t	class:simlib3::IntegratorContainer
iterator	simlib.h	/^  typedef std::list<Status*>::iterator iterator;$/;"	t	class:simlib3::StatusContainer
iterator	waitunti.cc	/^    typedef container_t::iterator iterator;$/;"	t	class:simlib3::WaitUntilList	file:
iterator	zdelay.cc	/^        typedef container_t::iterator iterator;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:
l	calendar.cc	/^    CalendarListImplementation l;$/;"	m	class:simlib3::CalendarList	file:
l	calendar.cc	/^    EventNoticeLinkBase *l; \/\/ single-linked list of freed items$/;"	m	class:simlib3::EventNoticeAllocator	file:
l	calendar.cc	/^    EventNoticeLinkBase l;  \/\/!< head of circular list$/;"	m	class:simlib3::CalendarListImplementation	file:
l	waitunti.cc	/^    container_t l;$/;"	m	class:simlib3::WaitUntilList	file:
last	simlib.h	/^    double last;        \/\/!< last sample time -- prevents sample duplication$/;"	m	class:simlib3::Sampler
last_dequeue_time	calendar.cc	/^    double last_dequeue_time; \/\/ for deleta computation$/;"	m	class:simlib3::CalendarQueue	file:
last_insert	delay.cc	/^    Pair last_insert;           \/\/ last inserted value (optimization)$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:
last_time	delay.h	/^    double last_time;           \/\/ last output (for optimization)$/;"	m	class:simlib3::Delay
last_value	delay.h	/^    double last_value;$/;"	m	class:simlib3::Delay
limit	optimize.h	/^    void limit(double &x)$/;"	f	class:simlib3::Param
limitation	_test_.cc	/^  Lim limitation;$/;"	m	struct:Test	file:
line	generr.c	/^char line[MAXLINELEN + 2];$/;"	v
lineno	generr.c	/^int lineno = 0;$/;"	v
list	calendar.cc	/^    BucketList list;        \/\/ list for small number of items$/;"	m	class:simlib3::CalendarQueue	file:
list_impl	calendar.cc	/^    bool list_impl() { return buckets==NULL; }$/;"	f	class:simlib3::CalendarQueue	file:
listptr	delay.cc	/^    static std::list<Delay *> *listptr; \/\/ list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_Delay	file:
listptr	delay.cc	/^std::list<Delay *> *SIMLIB_Delay::listptr = 0;$/;"	m	class:simlib3::SIMLIB_Delay	file:
lock	internal.h	/^    void lock() {$/;"	f	class:simlib3::AlgLoopDetector
low	simlib.h	/^  double   low;              \/\/ low bound$/;"	m	class:simlib3::Histogram
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim
low_bucket_mark	calendar.cc	/^    unsigned low_bucket_mark;       \/\/ low bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:
main	_test_.cc	/^int main() {                      \/\/ popis experimentu ...$/;"	f
main	generr.c	/^int main(int argc, char *argv[])$/;"	f
max	internal.h	/^inline double max(double a, double b) { return ((a)>(b)?(a):(b)); }$/;"	f	namespace:simlib3
max	optimize.h	/^    double max;$/;"	m	class:simlib3::Param
max	simlib.h	/^  double max;                   \/\/ max value x$/;"	m	class:simlib3::TStat
max	simlib.h	/^  double max;                   \/\/ max value$/;"	m	class:simlib3::Stat
max	simlib.h	/^  double max;                   \/\/ maximal recorded value$/;"	m	class:simlib3::aStat
maxn	simlib.h	/^  unsigned maxn;        \/\/!< barrier height\/size$/;"	m	class:simlib3::Barrier
mem_size	simlib.h	/^      size_t mem_size;  \/\/ allocated memory size$/;"	m	class:simlib3::IntegrationMethod::Memory
method_name	simlib.h	/^  const char* method_name;  \/\/ C-string --- the name of the method$/;"	m	class:simlib3::IntegrationMethod
min	internal.h	/^inline double min(double a, double b) { return ((a)>(b)?(b):(a)); }$/;"	f	namespace:simlib3
min	optimize.h	/^    double min;$/;"	m	class:simlib3::Param
min	simlib.h	/^  double min;                   \/\/ min value x$/;"	m	class:simlib3::TStat
min	simlib.h	/^  double min;                   \/\/ min value$/;"	m	class:simlib3::Stat
min	simlib.h	/^  double min;                   \/\/ minimal recorded value$/;"	m	class:simlib3::aStat
mintime	calendar.cc	/^    double mintime;     \/\/!< activation time of first event$/;"	m	class:simlib3::Calendar	file:
modfname	generr.c	/^char modfname[80];              \/* module file name *\/$/;"	v
move_to_next_point	opt-simann.cc	/^void move_to_next_point(ParameterVector & p, double eps)$/;"	f	namespace:simlib3
myint32	random1.cc	/^typedef int myint32;      \/\/ long has >32 bits$/;"	t	namespace:simlib3	file:
myint32	random1.cc	/^typedef long myint32;     \/\/ long has 32 bits$/;"	t	namespace:simlib3	file:
n	optimize.h	/^    int n;$/;"	m	class:simlib3::ParameterVector
n	simlib.h	/^    unsigned n;                          \/\/ number of objects in list$/;"	m	class:simlib3::List
n	simlib.h	/^  int n;                          \/\/ table item number$/;"	m	class:simlib3::Rline
n	simlib.h	/^  int n;$/;"	m	class:simlib3::Semaphore
n	simlib.h	/^  unsigned long n;              \/\/ number of records$/;"	m	class:simlib3::TStat
n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::Stat
n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::aStat
n	simlib.h	/^  unsigned n;           \/\/!< current number of waiting entities$/;"	m	class:simlib3::Barrier
name	optimize.h	/^    const char *name;           \/\/ name of parameter  c-string$/;"	m	class:simlib3::Param
nbuckets	calendar.cc	/^    unsigned nbuckets;      \/\/ current number of buckets$/;"	m	class:simlib3::CalendarQueue	file:
ndelta	calendar.cc	/^    unsigned ndelta;        \/\/ count$/;"	m	class:simlib3::CalendarQueue	file:
new_value	zdelay.h	/^    double new_value;   \/\/ stored input value$/;"	m	class:simlib3::ZDelay
next	simlib.h	/^    static Link *next(Link*p)           { return p->succ; }$/;"	f	class:simlib3::List
nextbucket	calendar.cc	/^    unsigned nextbucket;    \/\/ next bucket to check for first item$/;"	m	class:simlib3::CalendarQueue	file:
numop	calendar.cc	/^    unsigned numop;         \/\/ number of operations performed from last tuning$/;"	m	class:simlib3::CalendarQueue	file:
old_value	zdelay.h	/^    double old_value;   \/\/ output value (delayed signal)$/;"	m	class:simlib3::ZDelay
on	simlib.h	/^    bool on;            \/\/!< switch on\/off$/;"	m	class:simlib3::Sampler
operator !=	calendar.cc	/^      bool operator != (iterator q) { return p!=q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator
operator !=	simlib.h	/^            bool operator != (iterator q) const { return p!=q.p; }$/;"	f	class:simlib3::List::iterator
operator ()	histo.cc	/^void Histogram::operator () (double x)$/;"	f	class:simlib3::Histogram
operator ()	stat.cc	/^void Stat::operator () (double x)$/;"	f	class:simlib3::Stat
operator ()	tstat.cc	/^void TStat::operator () (double x)$/;"	f	class:simlib3::TStat
operator *	calendar.cc	/^      EventNotice * operator*() {$/;"	f	class:simlib3::CalendarListImplementation::iterator
operator *	continuous.cc	/^Input operator * (Input a, Input b) { return new _Mul(a,b); }$/;"	f	namespace:simlib3
operator *	simlib.h	/^            Link * operator*() const { return p; }$/;"	f	class:simlib3::List::iterator
operator *	simlib2D.cc	/^Input2D operator * (Input a, Input2D b)   { return new _Mul2D1D(b,a); }$/;"	f	namespace:simlib3
operator *	simlib2D.cc	/^Input2D operator * (Input2D a, Input b)   { return new _Mul2D1D(a,b); }$/;"	f	namespace:simlib3
operator *	simlib2D.cc	/^Value2D operator *(const Value2D& a, const double b)$/;"	f	namespace:simlib3
operator *	simlib2D.cc	/^Value2D operator *(const double a, const Value2D& b)$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Input3D operator * (Input a, Input3D b)   { return new _Mul3D1D(b,a); }$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input b)   { return new _Mul3D1D(a,b); }$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input3D b) { return new _Mul3D(a,b); }$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const double b)$/;"	f	namespace:simlib3
operator *	simlib3D.cc	/^Value3D operator *(const double a, const Value3D& b)$/;"	f	namespace:simlib3
operator +	continuous.cc	/^Input operator + (Input a, Input b) { return new _Add(a,b); }$/;"	f	namespace:simlib3
operator +	simlib2D.cc	/^Input2D operator + (Input2D a, Input2D b) { return new _Add2D(a,b); }$/;"	f	namespace:simlib3
operator +	simlib2D.cc	/^Value2D operator +(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3
operator +	simlib2D.h	/^  Value2D operator + (Value2D b) { return Value2D(_x+b._x, _y+b._y); }$/;"	f	class:simlib3::Value2D
operator +	simlib3D.cc	/^Input3D operator + (Input3D a, Input3D b) { return new _Add3D(a,b); }$/;"	f	namespace:simlib3
operator +	simlib3D.cc	/^Value3D operator +(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3
operator +	simlib3D.h	/^  Value3D operator + (Value3D b) { return Value3D(_x+b._x, _y+b._y, _z+b._z); }$/;"	f	class:simlib3::Value3D
operator ++	calendar.cc	/^      iterator &operator++() { p = p->succ; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator
operator ++	simlib.h	/^            iterator &operator++() { p = List::next(p); return *this; }$/;"	f	class:simlib3::List::iterator
operator ++	simlib.h	/^            iterator operator++(int) {$/;"	f	class:simlib3::List::iterator
operator -	continuous.cc	/^Input operator - (Input a) { return new _UMinus(a); }$/;"	f	namespace:simlib3
operator -	continuous.cc	/^Input operator - (Input a, Input b) { return new _Sub(a,b); }$/;"	f	namespace:simlib3
operator -	simlib2D.cc	/^Input2D operator - (Input2D a) { return new _UMinus2D(a); }$/;"	f	namespace:simlib3
operator -	simlib2D.cc	/^Input2D operator - (Input2D a, Input2D b) { return new _Sub2D(a,b); }$/;"	f	namespace:simlib3
operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a)$/;"	f	namespace:simlib3
operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3
operator -	simlib2D.h	/^  Value2D operator - (Value2D b) { return Value2D(_x-b._x, _y-b._y); }$/;"	f	class:simlib3::Value2D
operator -	simlib3D.cc	/^Input3D operator - (Input3D a) { return new _UMinus3D(a); }$/;"	f	namespace:simlib3
operator -	simlib3D.cc	/^Input3D operator - (Input3D a, Input3D b) { return new _Sub3D(a,b); }$/;"	f	namespace:simlib3
operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a)$/;"	f	namespace:simlib3
operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3
operator -	simlib3D.h	/^  Value3D operator - (Value3D b) { return Value3D(_x-b._x, _y-b._y, _z-b._z); }$/;"	f	class:simlib3::Value3D
operator --	calendar.cc	/^      iterator &operator--() { p = p->pred; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator
operator --	simlib.h	/^            iterator &operator--() { p = List::previous(p); return *this; }$/;"	f	class:simlib3::List::iterator
operator --	simlib.h	/^            iterator operator--(int) {$/;"	f	class:simlib3::List::iterator
operator /	continuous.cc	/^Input operator \/ (Input a, Input b) { return new _Div(a,b); }$/;"	f	namespace:simlib3
operator /	simlib2D.cc	/^Input2D operator \/ (Input2D a, Input b)   { return new _Div2D(a,b); }$/;"	f	namespace:simlib3
operator /	simlib2D.cc	/^Value2D operator \/(const Value2D& a, const double b)$/;"	f	namespace:simlib3
operator /	simlib3D.cc	/^Input3D operator \/ (Input3D a, Input b)   { return new _Div3D(a,b); }$/;"	f	namespace:simlib3
operator /	simlib3D.cc	/^Value3D operator \/(const Value3D& a, const double b)$/;"	f	namespace:simlib3
operator =	opt-param.cc	/^ParameterVector & ParameterVector::operator = (const ParameterVector & a) {$/;"	f	class:simlib3::ParameterVector
operator =	optimize.h	/^    Param & operator = (double x) {$/;"	f	class:simlib3::Param
operator =	print.cc	/^    void operator = (FILE *f)   { OutFile=f; }$/;"	f	class:simlib3::_FileWrap
operator =	simlib.h	/^            iterator &operator=(const iterator&x) { p = x.p; return *this; }$/;"	f	class:simlib3::List::iterator
operator =	simlib.h	/^  Input &operator= (const Input&x) {$/;"	f	class:simlib3::Input
operator =	simlib.h	/^  Integrator &operator= (double x) { Set(x); return *this; }$/;"	f	class:simlib3::Integrator
operator =	simlib.h	/^  Parameter &operator= (double x) { value = x; return *this; }$/;"	f	class:simlib3::Parameter
operator =	simlib.h	/^  Variable &operator= (double x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable
operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (Input2D i)$/;"	f	class:simlib3::Integrator2D
operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (const Value2D &a)$/;"	f	class:simlib3::Integrator2D
operator =	simlib2D.cc	/^Parameter2D &Parameter2D::operator= (const Value2D &x)    {$/;"	f	class:simlib3::Parameter2D
operator =	simlib2D.h	/^  Input2D&operator=(const Input2D&x) { bp=x.bp; return *this; }$/;"	f	class:simlib3::Input2D
operator =	simlib2D.h	/^  Variable2D &operator= (Value2D x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable2D
operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (Input3D i)$/;"	f	class:simlib3::Integrator3D
operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (const Value3D &a)$/;"	f	class:simlib3::Integrator3D
operator =	simlib3D.cc	/^Parameter3D &Parameter3D::operator= (const Value3D &x)    {$/;"	f	class:simlib3::Parameter3D
operator =	simlib3D.h	/^  Input3D&operator=(const Input3D &in) { bp = in.bp; return *this; }$/;"	f	class:simlib3::Input3D
operator =	simlib3D.h	/^  Variable3D &operator= (Value3D x) { value = x; return *this; }$/;"	f	class:simlib3::Variable3D
operator ==	calendar.cc	/^      bool operator == (iterator q) { return p==q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator
operator ==	delay.cc	/^        bool operator == (Pair &p) { return p.time==time && p.value==value; }$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair
operator ==	opt-param.cc	/^bool operator == (const ParameterVector & p1, const ParameterVector & p2) {$/;"	f	namespace:simlib3
operator ==	simlib.h	/^            bool operator == (iterator q) const { return p==q.p; }$/;"	f	class:simlib3::List::iterator
operator ==	simlib.h	/^  bool operator ==(aContiBlock *p) const { return bp==p; } \/\/ for tests only$/;"	f	class:simlib3::Input
operator ==	simlib2D.h	/^  bool operator ==(void *p) { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input2D
operator ==	simlib3D.h	/^  bool operator ==(void *p)       { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input3D
operator Entity*	simlib.h	/^    operator Entity* () { return this; } \/\/ default conversion$/;"	f	class:simlib3::Entity
operator FILE *	print.cc	/^    operator FILE *()           { return get(); }$/;"	f	class:simlib3::_FileWrap
operator Facility*	simlib.h	/^  operator Facility* () { return this; }$/;"	f	class:simlib3::Facility
operator Queue*	simlib.h	/^    operator Queue* () { return this; }  \/\/ allows Queue instead Queue*$/;"	f	class:simlib3::Queue
operator Semaphore*	simlib.h	/^  operator Semaphore* () { return this; }$/;"	f	class:simlib3::Semaphore
operator Store*	simlib.h	/^  operator Store* () { return this; }$/;"	f	class:simlib3::Store
operator ZDelayTimer *	zdelay.h	/^    operator ZDelayTimer * () { return this; }$/;"	f	class:simlib3::ZDelayTimer
operator []	histo.cc	/^unsigned Histogram::operator [] (unsigned i) const$/;"	f	class:simlib3::Histogram
operator []	optimize.h	/^    Param & operator[] (int i) { return p[i]; }$/;"	f	class:simlib3::ParameterVector
operator []	optimize.h	/^    Param & operator[](const char *name) {$/;"	f	class:simlib3::ParameterVector
operator []	optimize.h	/^    const Param & operator[] (int i) const { return p[i]; }$/;"	f	class:simlib3::ParameterVector
operator []	simlib.h	/^      double& operator[](size_t ind) {  \/\/ access the element of the array$/;"	f	class:simlib3::IntegrationMethod::Memory
operator delete	object.cc	/^void SimObject::operator delete(void *ptr) {$/;"	f	class:simlib3::SimObject
operator double	optimize.h	/^    operator double () const { return value; }$/;"	f	class:simlib3::Param
operator new	object.cc	/^void *SimObject::operator new(size_t size) {$/;"	f	class:simlib3::SimObject
opt_function_t	optimize.h	/^typedef double (*opt_function_t) (const ParameterVector & p);$/;"	t	namespace:simlib3
p	calendar.cc	/^      EventNoticeLinkBase *p;$/;"	m	class:simlib3::CalendarListImplementation::iterator	file:
p	optimize.h	/^    Param *p;$/;"	m	class:simlib3::ParameterVector
p	simlib.h	/^            Link *p; \/\/ position in List$/;"	m	class:simlib3::List::iterator
p1	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst
p1	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay
p1	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash
p2	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst
p2	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay
p2	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash
p3	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay
p4	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay
page_size	numint.cc	/^const size_t IntegrationMethod::Memory::page_size = 256;$/;"	m	class:simlib3::IntegrationMethod::Memory	file:
page_size	simlib.h	/^      static const size_t page_size;  \/\/ size of memory page$/;"	m	class:simlib3::IntegrationMethod::Memory
phase	simlib.h	/^  int phase; \/\/ phase of computation$/;"	m	class:simlib3::AlgLoop
prec	ni_fw.cc	/^const double FW::prec = DBL_EPSILON; \/\/ near zero number$/;"	m	class:simlib3::FW	file:
prec	ni_fw.h	/^  static const double prec; \/\/ near zero number$/;"	m	class:simlib3::FW
pred	calendar.cc	/^    EventNoticeLinkBase * pred;         \/\/!< previous object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:
pred	simlib.h	/^  Link *pred;                          \/\/!< previous object in List$/;"	m	class:simlib3::Link
prev_root	simlib.h	/^  double prev_root; \/\/ root from previous iteration step$/;"	m	class:simlib3::Newton
previous	simlib.h	/^    static Link *previous(Link*p)       { return p->pred; }$/;"	f	class:simlib3::List
priority	calendar.cc	/^    Entity::Priority_t priority;$/;"	m	struct:simlib3::EventNotice	file:
put	delay.cc	/^    virtual void put(double value, double time) {$/;"	f	class:simlib3::SIMLIB_DelayBuffer
rdtsc	rdtsc.h	/^static __inline__ unsigned long long rdtsc(void)$/;"	f
remove	calendar.cc	/^    Entity *remove(Entity *e) {$/;"	f	class:simlib3::CalendarListImplementation
remove	calendar.cc	/^    void remove() {$/;"	f	struct:simlib3::EventNoticeLinkBase
remove_first	calendar.cc	/^    Entity *remove_first() {$/;"	f	class:simlib3::CalendarListImplementation
root	simlib.h	/^  double root; \/\/ root of equation$/;"	m	class:simlib3::AlgLoop
scalar_product	simlib2D.cc	/^double scalar_product(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3
scalar_product	simlib3D.cc	/^double scalar_product(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3
search	calendar.cc	/^    iterator search(EventNotice *en) {$/;"	f	class:simlib3::CalendarListImplementation	file:
search	opt-param.cc	/^int ParameterVector::search(const char *name)$/;"	f	class:simlib3::ParameterVector
si	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER
si	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE
sign	fun.cc	/^static double sign(double x)$/;"	f	namespace:simlib3
simlib3	algloop.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	atexit.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	barrier.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	calendar.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	cond.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	continuous.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	debug.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	delay.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	delay.h	/^namespace simlib3 {$/;"	n
simlib3	entity.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	error.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	errors.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	event.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	facility.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	fun.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	graph.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	histo.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	internal.h	/^namespace simlib3 {$/;"	n
simlib3	intg.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	link.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	list.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	name.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_abm4.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_abm4.h	/^namespace simlib3 {$/;"	n
simlib3	ni_euler.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_euler.h	/^namespace simlib3 {$/;"	n
simlib3	ni_fw.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_fw.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rke.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rke.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf3.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf3.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf5.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf5.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf8.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf8.h	/^namespace simlib3 {$/;"	n
simlib3	numint.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	object.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-hooke.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-param.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-simann.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	optimize.h	/^namespace simlib3 {$/;"	n
simlib3	output1.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	output2.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	print.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	process.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	queue.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	random1.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	random2.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	run.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	sampler.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	semaphor.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib.h	/^namespace simlib3 {$/;"	n
simlib3	simlib2D.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib2D.h	/^namespace simlib3 {$/;"	n
simlib3	simlib3D.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib3D.h	/^namespace simlib3 {$/;"	n
simlib3	stat.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	stdblock.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	store.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	tstat.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	version.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	waitunti.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	zdelay.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	zdelay.h	/^namespace simlib3 {$/;"	n
size	optimize.h	/^    int size() const { return n; }$/;"	f	class:simlib3::ParameterVector
size	process.cc	/^    size_t size;        \/\/ size of following array (allocated on heap)$/;"	m	struct:simlib3::P_Context_t	file:
size	simlib.h	/^    unsigned size() const  { return n; }$/;"	f	class:simlib3::List
sp	generr.c	/^char *sp = line;$/;"	v
special_input	simlib2D.h	/^    special_input(Input2D i) : a(0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator2D::special_input
special_input	simlib2D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator2D
special_input	simlib3D.h	/^    special_input(Input3D i) : a(0,0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator3D::special_input
special_input	simlib3D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator3D
ss	simlib.h	/^  double ss;                           \/\/ status: y = S f(t,y) dt$/;"	m	class:simlib3::Integrator
ssl	simlib.h	/^  double ssl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator
st	simlib.h	/^  double st;                           \/\/!< status$/;"	m	class:simlib3::Status
stack	process.cc	/^    char stack[1];      \/\/ stack contents saved$/;"	m	struct:simlib3::P_Context_t	file:
stat	simlib.h	/^  Stat     stat;             \/\/ statistics$/;"	m	class:simlib3::Histogram
status	process.cc	/^    jmp_buf status;     \/\/ stored SP, IP, and other registers$/;"	m	struct:simlib3::P_Context_t	file:
step	simlib.h	/^    double step;        \/\/!< step of sampling$/;"	m	class:simlib3::Sampler
step	simlib.h	/^  double   step;             \/\/ interval width$/;"	m	class:simlib3::Histogram
step	simlib.h	/^  double step;                    \/\/ quantum$/;"	m	class:simlib3::Qntzr
stl	simlib.h	/^  double stl;                          \/\/!< status from previous step$/;"	m	class:simlib3::Status
string	internal.h	/^  const char *string; \/\/ module identification string$/;"	m	class:simlib3::SIMLIB_module
succ	calendar.cc	/^    EventNoticeLinkBase * succ;         \/\/!< next object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:
succ	simlib.h	/^  Link *succ;                          \/\/!< next object in List$/;"	m	class:simlib3::Link
sumdelta	calendar.cc	/^    double sumdelta;        \/\/ sum for bucket_width estimation$/;"	m	class:simlib3::CalendarQueue	file:
switchtocq	calendar.cc	/^void CalendarQueue::switchtocq()$/;"	f	class:simlib3::CalendarQueue
switchtolist	calendar.cc	/^void CalendarQueue::switchtolist()$/;"	f	class:simlib3::CalendarQueue
sx	simlib.h	/^  double sx;                    \/\/ sum of values$/;"	m	class:simlib3::Stat
sx2	simlib.h	/^  double sx2;                   \/\/ sum of value square$/;"	m	class:simlib3::Stat
sx2t	simlib.h	/^  double sx2t;                  \/\/ sum of squares$/;"	m	class:simlib3::TStat
sxt	simlib.h	/^  double sxt;                   \/\/ sum of x*time$/;"	m	class:simlib3::TStat
t0	simlib.h	/^  double t0;                    \/\/ time of initialization$/;"	m	class:simlib3::TStat
tab	generr.c	/^TABLE *tab;$/;"	v
tabitem	generr.c	/^struct tabitem {$/;"	s	file:
tableX	simlib.h	/^  double *tableX;                 \/\/ tabulka X$/;"	m	class:simlib3::Rline
tableY	simlib.h	/^  double *tableY;                 \/\/ tabulka Y$/;"	m	class:simlib3::Rline
tga	simlib.h	/^    double tga;$/;"	m	class:simlib3::Hyst
tga	simlib.h	/^  double tga;$/;"	m	class:simlib3::Blash
tgalpha	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv
tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Frict
tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Lim
tgbeta	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv
time	calendar.cc	/^    double time;$/;"	m	struct:simlib3::EventNotice	file:
time	delay.cc	/^        double time;$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:
time2bucket	calendar.cc	/^    inline int time2bucket (double t) {$/;"	f	class:simlib3::CalendarQueue	file:
time2bucket_top	calendar.cc	/^    inline double time2bucket_top(double t) {$/;"	f	class:simlib3::CalendarQueue	file:
tittle	generr.c	/^char tittle[] =$/;"	v
tl	simlib.h	/^  double tl;                    \/\/ last record time$/;"	m	class:simlib3::TStat
tstat	simlib.h	/^  TStat tstat;                  \/\/!< usage statistics$/;"	m	class:simlib3::Store
tstat	simlib.h	/^  TStat tstat;               \/\/ stat$/;"	m	class:simlib3::Facility
unlock	internal.h	/^    void unlock() {$/;"	f	class:simlib3::AlgLoopDetector
used	simlib.h	/^  unsigned long used;            \/\/ used capacity$/;"	m	class:simlib3::Store
v	_test_.cc	/^  Integrator v;$/;"	m	struct:Test	file:
value	delay.cc	/^        double value;$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:
value	optimize.h	/^    double value;$/;"	m	class:simlib3::Param
value	simlib.h	/^  const double value;$/;"	m	class:simlib3::Constant
value	simlib.h	/^  double value;$/;"	m	class:simlib3::Parameter
value	simlib.h	/^  double value;$/;"	m	class:simlib3::Variable
value	simlib2D.h	/^  Value2D value;$/;"	m	class:simlib3::Variable2D
value	simlib2D.h	/^  const Value2D value;$/;"	m	class:simlib3::Constant2D
value	simlib3D.h	/^  Value3D value;$/;"	m	class:simlib3::Variable3D
value	simlib3D.h	/^  const Value3D value;$/;"	m	class:simlib3::Constant3D
visualize	calendar.cc	/^void CalendarQueue::visualize(const char *msg)$/;"	f	class:simlib3::CalendarQueue
waiting	simlib.h	/^  Entity **waiting;     \/\/!< array of waiting entities (fixed size)$/;"	m	class:simlib3::Barrier
was_cycle	simlib.h	/^  bool was_cycle; \/\/ flag for going through loop$/;"	m	class:simlib3::AlgLoop
which	simlib2D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYpart	file:
which	simlib3D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYZpart	file:
x	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
x	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D
x	simlib2D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value2D
x	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
x	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D
x	simlib3D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value3D
xi	ni_euler.h	/^  StatusMemory xi;$/;"	m	class:simlib3::EULER
xi	ni_rke.h	/^  StatusMemory xi;$/;"	m	class:simlib3::RKE
xl	simlib.h	/^  double xl;                    \/\/ last recorded value x$/;"	m	class:simlib3::TStat
y	_test_.cc	/^  Status y;$/;"	m	struct:Test	file:
y	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
y	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D
y	simlib2D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value2D
y	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
y	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D
y	simlib3D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value3D
y1	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst
y1	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay
y2	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst
y2	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay
z	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
z	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D
z	simlib3D.h	/^  double z() const { return _z; }$/;"	f	class:simlib3::Value3D
~ABM4	ni_abm4.h	/^  virtual ~ABM4()  \/\/ destructor$/;"	f	class:simlib3::ABM4
~AlgLoopDetector	internal.h	/^    ~AlgLoopDetector() { unlock(); }$/;"	f	class:simlib3::AlgLoopDetector
~Barrier	barrier.cc	/^Barrier::~Barrier() {$/;"	f	class:simlib3::Barrier
~Buffer	delay.cc	/^        virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer
~Buffer	delay.h	/^        virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer
~Calendar	calendar.cc	/^    virtual ~Calendar() {} \/\/!< clear is called in derived class dtr$/;"	f	class:simlib3::Calendar
~CalendarList	calendar.cc	/^    ~CalendarList() {$/;"	f	class:simlib3::CalendarList	file:
~CalendarListImplementation	calendar.cc	/^    ~ CalendarListImplementation() {$/;"	f	class:simlib3::CalendarListImplementation
~CalendarQueue	calendar.cc	/^CalendarQueue::~CalendarQueue()$/;"	f	class:simlib3::CalendarQueue
~Condition	cond.cc	/^Condition::~Condition()$/;"	f	class:simlib3::Condition
~Delay	delay.cc	/^Delay::~Delay()$/;"	f	class:simlib3::Delay
~EULER	ni_euler.h	/^  virtual ~EULER()  \/\/ destructor$/;"	f	class:simlib3::EULER
~Entity	entity.cc	/^Entity::~Entity() {$/;"	f	class:simlib3::Entity
~Event	event.cc	/^Event::~Event()$/;"	f	class:simlib3::Event
~EventNotice	calendar.cc	/^    ~EventNotice() {$/;"	f	struct:simlib3::EventNotice
~EventNoticeAllocator	calendar.cc	/^    ~EventNoticeAllocator() {$/;"	f	class:simlib3::EventNoticeAllocator
~FW	ni_fw.h	/^  virtual ~FW()  \/\/ destructor$/;"	f	class:simlib3::FW
~Facility	facility.cc	/^Facility::~Facility()$/;"	f	class:simlib3::Facility
~Graph	graph.cc	/^Graph::~Graph()$/;"	f	class:simlib3::Graph
~Histogram	histo.cc	/^Histogram::~Histogram()$/;"	f	class:simlib3::Histogram
~Input	simlib.h	/^  ~Input() { UnRegisterReference(bp); }$/;"	f	class:simlib3::Input
~IntegrationMethod	numint.cc	/^IntegrationMethod::~IntegrationMethod() {$/;"	f	class:simlib3::IntegrationMethod
~Integrator	intg.cc	/^Integrator::~Integrator()$/;"	f	class:simlib3::Integrator
~Link	link.cc	/^Link::~Link() {$/;"	f	class:simlib3::Link
~List	list.cc	/^List::~List() {$/;"	f	class:simlib3::List
~Memory	numint.cc	/^IntegrationMethod::Memory::~Memory()$/;"	f	class:simlib3::IntegrationMethod::Memory
~MultiStepMethod	numint.cc	/^MultiStepMethod::~MultiStepMethod()$/;"	f	class:simlib3::MultiStepMethod
~ParameterVector	opt-param.cc	/^ParameterVector::~ParameterVector()$/;"	f	class:simlib3::ParameterVector
~Process	process.cc	/^Process::~Process()$/;"	f	class:simlib3::Process
~Queue	queue.cc	/^Queue::~Queue() {$/;"	f	class:simlib3::Queue
~RKE	ni_rke.h	/^  virtual ~RKE()  \/\/ destructor$/;"	f	class:simlib3::RKE
~RKF3	ni_rkf3.h	/^  virtual ~RKF3()  \/\/ destructor$/;"	f	class:simlib3::RKF3
~RKF5	ni_rkf5.h	/^  virtual ~RKF5()  \/\/ destructor$/;"	f	class:simlib3::RKF5
~RKF8	ni_rkf8.h	/^  virtual ~RKF8()  \/\/ destructor$/;"	f	class:simlib3::RKF8
~Rline	stdblock.cc	/^Rline::~Rline()$/;"	f	class:simlib3::Rline
~SIMLIB_module	atexit.cc	/^SIMLIB_module::~SIMLIB_module() {$/;"	f	class:simlib3::SIMLIB_module
~Sampler	sampler.cc	/^Sampler::~Sampler()$/;"	f	class:simlib3::Sampler
~Semaphore	semaphor.cc	/^Semaphore::~Semaphore()$/;"	f	class:simlib3::Semaphore
~SimObject	object.cc	/^SimObject::~SimObject()$/;"	f	class:simlib3::SimObject
~Stat	stat.cc	/^Stat::~Stat()$/;"	f	class:simlib3::Stat
~Status	intg.cc	/^Status::~Status() {$/;"	f	class:simlib3::Status
~StatusMemory	simlib.h	/^    virtual ~StatusMemory() { }$/;"	f	class:simlib3::StatusMethod::StatusMemory
~StatusMethod	simlib.h	/^  virtual ~StatusMethod() { } \/\/ free dynamic datas$/;"	f	class:simlib3::StatusMethod
~Store	store.cc	/^Store::~Store()$/;"	f	class:simlib3::Store
~TStat	tstat.cc	/^TStat::~TStat()$/;"	f	class:simlib3::TStat
~WaitUntilList	waitunti.cc	/^    ~WaitUntilList() { Dprintf(("WaitUntilList::~WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:
~ZDelay	zdelay.cc	/^ZDelay::~ZDelay()$/;"	f	class:simlib3::ZDelay
~ZDelayTimer	zdelay.cc	/^ZDelayTimer::~ZDelayTimer()$/;"	f	class:simlib3::ZDelayTimer
~_Add	continuous.cc	/^  ~_Add() {$/;"	f	class:simlib3::_Add
~_Div	continuous.cc	/^  ~_Div() {$/;"	f	class:simlib3::_Div
~_Mul	continuous.cc	/^  ~_Mul() {$/;"	f	class:simlib3::_Mul
~_Sub	continuous.cc	/^  ~_Sub() {$/;"	f	class:simlib3::_Sub
~_UMinus	continuous.cc	/^  ~_UMinus() {$/;"	f	class:simlib3::_UMinus
~aCondition	cond.cc	/^aCondition::~aCondition() {$/;"	f	class:simlib3::aCondition
~aContiBlock2D	simlib2D.cc	/^aContiBlock2D::~aContiBlock2D() {$/;"	f	class:simlib3::aContiBlock2D
~aContiBlock3D	simlib3D.cc	/^aContiBlock3D::~aContiBlock3D() {$/;"	f	class:simlib3::aContiBlock3D
